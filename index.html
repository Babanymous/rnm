 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Central Finite Curve - Enhanced</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(ellipse at center, #0a0a15 0%, #000000 100%);
            font-family: 'Roboto Mono', monospace; 
        }
        
        #ui-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .hud-header {
            padding: 25px 30px;
            background: linear-gradient(180deg, rgba(5,15,5,0.95) 0%, rgba(5,15,5,0.7) 70%, transparent 100%);
            border-bottom: 2px solid rgba(151, 206, 76, 0.4);
            box-shadow: 0 4px 20px rgba(151, 206, 76, 0.2);
        }

        h1 { 
            margin: 0; 
            color: #97ce4c; 
            font-family: 'Orbitron', sans-serif; 
            font-size: 32px; 
            font-weight: 900;
            letter-spacing: 3px; 
            text-shadow: 0 0 20px rgba(151, 206, 76, 1), 0 0 40px rgba(151, 206, 76, 0.5);
            animation: glitch 3s infinite;
        }
        
        @keyframes glitch {
            0%, 90%, 100% { opacity: 1; }
            92%, 94% { opacity: 0.8; transform: translateX(2px); }
            93%, 95% { opacity: 0.9; transform: translateX(-2px); }
        }
        
        .subtitle { 
            color: #4cb5ce; 
            font-size: 13px; 
            margin-top: 8px; 
            opacity: 0.9;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(76, 181, 206, 0.8);
        }

        .hud-footer {
            padding: 20px 30px;
            background: linear-gradient(0deg, rgba(5,15,5,0.95) 0%, rgba(5,15,5,0.7) 70%, transparent 100%);
            border-top: 2px solid rgba(151, 206, 76, 0.4);
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        .legend {
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .legend-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
        }

        .controls-hint {
            font-size: 11px;
            color: #666;
            text-align: right;
        }

        #scanner-modal {
            position: absolute;
            top: 50%; right: 30px;
            transform: translateY(-50%);
            width: 380px;
            background: rgba(5, 10, 5, 0.98);
            border: 2px solid #97ce4c;
            border-right: 5px solid #97ce4c;
            padding: 0;
            color: #fff;
            display: none;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: -15px 0 40px rgba(0,0,0,0.9), 0 0 30px rgba(151, 206, 76, 0.3);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateY(-50%) translateX(100px); opacity: 0; }
            to { transform: translateY(-50%) translateX(0); opacity: 1; }
        }

        .modal-header {
            background: linear-gradient(135deg, rgba(151, 206, 76, 0.2) 0%, rgba(151, 206, 76, 0.05) 100%);
            padding: 20px;
            border-bottom: 1px solid rgba(151, 206, 76, 0.3);
            position: relative;
            overflow: hidden;
        }

        .modal-header::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(151, 206, 76, 0.1), transparent);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            to { left: 100%; }
        }

        .modal-header h2 { 
            margin: 0; 
            color: #fff; 
            font-size: 20px; 
            font-family: 'Orbitron', sans-serif; 
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .modal-type { 
            color: #97ce4c; 
            font-size: 12px; 
            text-transform: uppercase; 
            margin-top: 8px; 
            display: block;
            letter-spacing: 2px;
            font-weight: 700;
        }

        .modal-body { padding: 20px; }
        
        .stat-row { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 14px; 
            font-size: 14px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .stat-label { 
            color: #888; 
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 1px;
        }
        
        .stat-val { 
            color: #eee; 
            font-weight: bold; 
            text-align: right;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .description {
            margin: 15px 0;
            padding: 12px;
            background: rgba(76, 181, 206, 0.05);
            border-left: 3px solid #4cb5ce;
            font-size: 12px;
            line-height: 1.6;
            color: #bbb;
            font-style: italic;
        }

        .residents-box {
            margin-top: 20px;
            border-top: 2px solid rgba(151, 206, 76, 0.2);
            padding-top: 15px;
        }
        
        .res-title { 
            font-size: 12px; 
            color: #4cb5ce; 
            text-transform: uppercase; 
            margin-bottom: 12px;
            letter-spacing: 2px;
            font-weight: 700;
        }
        
        #res-list {
            max-height: 120px;
            overflow-y: auto;
            font-size: 13px;
            color: #aaa;
            padding-left: 0;
            list-style: none;
            margin: 0;
        }
        
        #res-list::-webkit-scrollbar { width: 6px; }
        #res-list::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        #res-list::-webkit-scrollbar-thumb { background: #97ce4c; border-radius: 3px; }
        
        #res-list li { 
            padding: 6px 10px; 
            border-bottom: 1px solid rgba(255,255,255,0.05);
            transition: background 0.2s;
        }
        
        #res-list li:hover {
            background: rgba(151, 206, 76, 0.1);
        }

        #loading-overlay {
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, #0a0a15 0%, #000000 100%);
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center;
            z-index: 999;
            transition: opacity 1s ease;
        }
        
        .portal-spin {
            width: 80px; height: 80px;
            border: 6px solid transparent;
            border-top-color: #97ce4c;
            border-right-color: #4cb5ce;
            border-radius: 50%;
            animation: portalSpin 1s linear infinite;
            position: relative;
        }

        .portal-spin::before,
        .portal-spin::after {
            content: '';
            position: absolute;
            border-radius: 50%;
        }

        .portal-spin::before {
            top: 5px; left: 5px; right: 5px; bottom: 5px;
            border: 6px solid transparent;
            border-bottom-color: #97ce4c;
            border-left-color: #4cb5ce;
            animation: portalSpin 1.5s linear infinite reverse;
        }

        .portal-spin::after {
            top: 15px; left: 15px; right: 15px; bottom: 15px;
            border: 6px solid transparent;
            border-top-color: #4cb5ce;
            animation: portalSpin 2s linear infinite;
        }
        
        @keyframes portalSpin { 
            100% { transform: rotate(360deg); } 
        }

        .loading-text {
            margin-top: 30px;
            color: #97ce4c;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(151, 206, 76, 0.8);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .scan-line {
            width: 100%; height: 2px; 
            background: linear-gradient(90deg, transparent, #97ce4c, transparent);
            position: absolute; top: 0; left: 0;
            animation: scan 2s linear infinite;
            opacity: 0.6;
            pointer-events: none;
            box-shadow: 0 0 10px #97ce4c;
        }
        
        @keyframes scan { 
            0% { top: 0; opacity: 0; } 
            50% { opacity: 1; } 
            100% { top: 100%; opacity: 0; } 
        }

        @media (max-width: 768px) {
            #scanner-modal {
                width: 90%;
                right: 5%;
            }
            
            h1 { font-size: 24px; }
            
            .legend { gap: 15px; }
            
            .hud-footer {
                flex-direction: column;
                gap: 15px;
            }
        }

    </style>
</head>
<body>

    <div id="loading-overlay">
        <div class="portal-spin"></div>
        <div class="loading-text">INITIATING PORTAL GUN...</div>
    </div>

    <div id="ui-container">
        <div class="hud-header">
            <h1>âš¡ THE CENTRAL FINITE CURVE âš¡</h1>
            <div class="subtitle">INTERDIMENSIONAL CARTOGRAPHY SYSTEM // DIMENSION C-137 PRIMARY NODE</div>
        </div>

        <div class="hud-footer">
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-icon" style="background: #3498db;"></div>
                    <span>Planet</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon" style="background: #9b59b6;"></div>
                    <span>Dimension</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon" style="background: #95a5a6;"></div>
                    <span>Station</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon" style="background: #e74c3c;"></div>
                    <span>Microverse</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon" style="background: #97ce4c;"></div>
                    <span>Special</span>
                </div>
            </div>
            <div class="controls-hint">
                DRAG TO ROTATE â€¢ SCROLL TO ZOOM â€¢ CLICK TO SCAN
            </div>
        </div>
    </div>

    <div id="scanner-modal">
        <div class="scan-line"></div>
        <div class="modal-header">
            <h2 id="info-name">Earth (C-137)</h2>
            <span class="modal-type" id="info-type">Planet</span>
        </div>
        <div class="modal-body">
            <div class="stat-row">
                <span class="stat-label">Dimension</span>
                <span class="stat-val" id="info-dim">C-137</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Population</span>
                <span class="stat-val" id="info-pop">Unknown</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Threat Level</span>
                <span class="stat-val" id="info-threat">Unknown</span>
            </div>
            
            <div class="description" id="info-desc">
                Scanning location data...
            </div>
            
            <div class="residents-box">
                <div class="res-title">âš¡ DETECTED LIFEFORMS</div>
                <ul id="res-list">
                    <li>Scanning...</li>
                </ul>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.008);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 40, 80);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3;
        controls.maxDistance = 300;
        controls.minDistance = 20;

        // Enhanced Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 1.5); 
        scene.add(ambientLight);
        
        const sunLight = new THREE.PointLight(0xffffff, 2.5, 400);
        sunLight.position.set(0, 80, 0);
        scene.add(sunLight);

        const portalLight = new THREE.PointLight(0x97ce4c, 4, 150);
        portalLight.position.set(0, 0, 0);
        scene.add(portalLight);

        const blueAccent = new THREE.PointLight(0x4cb5ce, 2, 100);
        blueAccent.position.set(-50, 20, 50);
        scene.add(blueAccent);

        // Enhanced Starfield with multiple layers
        function createStarfield() {
            const starsGroup = new THREE.Group();
            
            // Background stars
            const bgGeometry = new THREE.BufferGeometry();
            const bgCount = 8000;
            const bgPositions = new Float32Array(bgCount * 3);
            const bgColors = new Float32Array(bgCount * 3);

            for(let i = 0; i < bgCount; i++) {
                bgPositions[i*3] = (Math.random() - 0.5) * 1000;
                bgPositions[i*3+1] = (Math.random() - 0.5) * 1000;
                bgPositions[i*3+2] = (Math.random() - 0.5) * 1000;
                
                const colorType = Math.random();
                if(colorType > 0.95) { 
                    bgColors[i*3] = 0.59; bgColors[i*3+1] = 0.8; bgColors[i*3+2] = 0.3; // Green
                } else if(colorType > 0.9) {
                    bgColors[i*3] = 0.3; bgColors[i*3+1] = 0.7; bgColors[i*3+2] = 0.8; // Blue
                } else {
                    const brightness = 0.6 + Math.random() * 0.4;
                    bgColors[i*3] = brightness; bgColors[i*3+1] = brightness; bgColors[i*3+2] = brightness + 0.1; 
                }
            }
            
            bgGeometry.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
            bgGeometry.setAttribute('color', new THREE.BufferAttribute(bgColors, 3));
            
            const bgMaterial = new THREE.PointsMaterial({ 
                size: 0.6, 
                vertexColors: true, 
                transparent: true, 
                opacity: 0.9,
                sizeAttenuation: true
            });
            
            const bgStars = new THREE.Points(bgGeometry, bgMaterial);
            starsGroup.add(bgStars);

            return starsGroup;
        }
        
        scene.add(createStarfield());

        // Enhanced Citadel with more detail
        function createCitadel() {
            const citadelGroup = new THREE.Group();
            
            const matGreen = new THREE.MeshStandardMaterial({ 
                color: 0x97ce4c, 
                emissive: 0x97ce4c,
                emissiveIntensity: 0.4,
                roughness: 0.3, 
                metalness: 0.8 
            });
            
            const matDark = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a, 
                roughness: 0.6, 
                metalness: 0.9 
            });

            const matGlass = new THREE.MeshPhysicalMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.3,
                roughness: 0.1,
                metalness: 0.1,
                transmission: 0.9,
                thickness: 0.5
            });

            // Main central tower (taller and more detailed)
            const towerGeo = new THREE.CylinderGeometry(3, 4, 30, 8);
            const tower = new THREE.Mesh(towerGeo, matDark);
            tower.position.y = 0;
            citadelGroup.add(tower);

            // Top dome (more prominent)
            const domeGeo = new THREE.SphereGeometry(5, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const dome = new THREE.Mesh(domeGeo, matGlass);
            dome.position.y = 15;
            citadelGroup.add(dome);

            // Glowing top sphere
            const topSphereGeo = new THREE.SphereGeometry(2, 16, 16);
            const topSphere = new THREE.Mesh(topSphereGeo, matGreen);
            topSphere.position.y = 18;
            citadelGroup.add(topSphere);

            // Multiple rings at different heights
            for(let i = 0; i < 3; i++) {
                const ringGeo = new THREE.TorusGeometry(8 + i * 2, 0.4, 16, 32);
                const ring = new THREE.Mesh(ringGeo, matGreen);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = -5 - i * 8;
                citadelGroup.add(ring);
            }

            // Satellites around the citadel (more of them)
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const distance = 15;
                
                const satelliteGeo = new THREE.CylinderGeometry(0.8, 0.8, 5, 6);
                const satellite = new THREE.Mesh(satelliteGeo, matDark);
                satellite.position.set(
                    Math.cos(angle) * distance, 
                    -8, 
                    Math.sin(angle) * distance
                );
                
                const glowGeo = new THREE.SphereGeometry(0.5, 8, 8);
                const glow = new THREE.Mesh(glowGeo, matGreen);
                glow.position.y = 3;
                satellite.add(glow);
                
                citadelGroup.add(satellite);
            }

            // Landing platforms
            for(let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2 + Math.PI/4;
                const platformGeo = new THREE.BoxGeometry(4, 0.5, 4);
                const platform = new THREE.Mesh(platformGeo, matDark);
                platform.position.set(
                    Math.cos(angle) * 12,
                    -15,
                    Math.sin(angle) * 12
                );
                citadelGroup.add(platform);
            }

            const userData = {
                name: "The Citadel of Ricks",
                type: "Space Station",
                dimension: "Trans-Dimensional",
                residents: [], 
                isCitadel: true,
                description: "The governing body for all Ricks and Mortys in the Central Finite Curve. A massive space station where thousands of alternate versions coexist.",
                threat: "EXTREME"
            };
            
            citadelGroup.children.forEach(child => {
                child.userData = userData;
            });

            citadelGroup.position.set(0, 0, 0);
            return citadelGroup;
        }

        const citadel = createCitadel();
        scene.add(citadel);

        const interactables = [];
        interactables.push(...citadel.children);

        // Lore-accurate custom locations with detailed descriptions
        const customLocations = [
            {
                name: "Anatomy Park",
                type: "Microverse",
                dimension: "C-137",
                color: 0xe74c3c,
                shape: "microverse",
                scale: 1.5,
                description: "A theme park built inside a homeless man's body. Features attractions like Pirates of the Pancreas and Haunted Liver.",
                threat: "HIGH",
                position: { x: 25, y: 5, z: 15 }
            },
            {
                name: "Cronenberg World",
                type: "Planet",
                dimension: "Cronenberg",
                color: 0x8B4513,
                shape: "planet",
                scale: 1.8,
                description: "Rick's original dimension where a love potion went catastrophically wrong, transforming everyone into grotesque Cronenberg monsters.",
                threat: "CRITICAL",
                position: { x: -30, y: -10, z: 20 }
            },
            {
                name: "Blips and Chitz",
                type: "Space Station",
                dimension: "C-137",
                color: 0xf1c40f,
                shape: "station",
                scale: 1.3,
                description: "The ultimate intergalactic arcade. Home to Roy: A Life Well Lived and countless other immersive games.",
                threat: "LOW",
                position: { x: 40, y: 15, z: -10 }
            },
            {
                name: "Gazorpazorp",
                type: "Planet",
                dimension: "C-137",
                color: 0xe84393,
                shape: "planet",
                scale: 1.6,
                description: "A war-torn planet ruled by giant warrior women. The males live as subservient beings.",
                threat: "EXTREME",
                position: { x: -20, y: 8, z: -35 }
            },
            {
                name: "Purge Planet",
                type: "Planet",
                dimension: "unknown",
                color: 0xa00000,
                shape: "planet",
                scale: 1.5,
                description: "A planet that annually celebrates a festival of murder and mayhem, blessed by their cat-like god.",
                threat: "CRITICAL",
                position: { x: 15, y: -15, z: -40 }
            },
            {
                name: "Froopyland",
                type: "Dimension",
                dimension: "Froop",
                color: 0xff69b4,
                shape: "dimension",
                scale: 1.4,
                description: "A fantasy world created by Rick for Beth. Tommy lives here now after... the incident.",
                threat: "MODERATE",
                position: { x: -40, y: 12, z: 5 }
            },
            {
                name: "Unity's World",
                type: "Planet",
                dimension: "C-137",
                color: 0x9b59b6,
                shape: "planet",
                scale: 1.7,
                description: "Home to Unity, the hive-mind entity and Rick's former lover. An entire civilization controlled by one consciousness.",
                threat: "HIGH",
                position: { x: 35, y: -8, z: 30 }
            },
            {
                name: "Pluto",
                type: "Planet",
                dimension: "C-137",
                color: 0xb8860b,
                shape: "planet",
                scale: 1.2,
                description: "Scientifically not a planet anymore, but Jerry didn't need to know that. Rich in plutonium.",
                threat: "LOW",
                position: { x: -15, y: 20, z: -15 }
            },
            {
                name: "Gear World",
                type: "Planet",
                dimension: "Gear",
                color: 0x708090,
                shape: "planet",
                scale: 1.3,
                description: "A dimension where everything and everyone is made of gears. Gearhead's home dimension.",
                threat: "LOW",
                position: { x: 28, y: -12, z: -25 }
            },
            {
                name: "Hamster in Butt World",
                type: "Dimension",
                dimension: "HIB",
                color: 0xffc0cb,
                shape: "dimension",
                scale: 1.1,
                description: "Everyone has a hamster in their butt. It's exactly what it sounds like.",
                threat: "LOW",
                position: { x: -32, y: -5, z: -20 }
            },
            {
                name: "Testicle Monster Dimension",
                type: "Dimension",
                dimension: "TM",
                color: 0xdda15e,
                shape: "dimension",
                scale: 1.2,
                description: "A dimension inhabited entirely by testicle-shaped monsters. Best not to linger.",
                threat: "MODERATE",
                position: { x: 22, y: 18, z: 35 }
            },
            {
                name: "Bird World",
                type: "Planet",
                dimension: "C-137",
                color: 0x00bfff,
                shape: "planet",
                scale: 1.5,
                description: "Birdperson's home planet. A society of highly intelligent avian warriors. In memoriam.",
                threat: "MODERATE",
                position: { x: 45, y: 3, z: -15 }
            },
            {
                name: "Microverse Battery",
                type: "Microverse",
                dimension: "C-137",
                color: 0xff4500,
                shape: "microverse",
                scale: 1.8,
                description: "A universe Rick created to power his spaceship. Contains civilizations unaware they're generating electricity.",
                threat: "MODERATE",
                position: { x: -25, y: -18, z: 28 }
            },
            {
                name: "Glorzo Outpost",
                type: "Space Station",
                dimension: "unknown",
                color: 0x4169e1,
                shape: "station",
                scale: 1.2,
                description: "An outpost selling illegal alien pheromones. They're not subtle about it.",
                threat: "MODERATE",
                position: { x: 18, y: 22, z: -30 }
            },
            {
                name: "Doofus Rick's Universe",
                type: "Dimension",
                dimension: "J19Î¶7",
                color: 0x87ceeb,
                shape: "dimension",
                scale: 1.3,
                description: "Home of Jerry's friend Rick, the nicest and 'dumbest' Rick. He never had a Beth.",
                threat: "MINIMAL",
                position: { x: -48, y: 8, z: -8 }
            }
        ];

        // Enhanced shape creation with better models
        function getShapeForType(type, color, scale = 1) {
            let mesh;
            
            if (type === "station") {
                // Octahedron station with glowing core
                const geo = new THREE.OctahedronGeometry(1.5 * scale, 1);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: 0xaaaaaa, 
                    roughness: 0.3, 
                    metalness: 0.9,
                    emissive: color,
                    emissiveIntensity: 0.2
                });
                mesh = new THREE.Mesh(geo, mat);
                
                // Add glowing core
                const coreGeo = new THREE.SphereGeometry(0.5 * scale, 8, 8);
                const coreMat = new THREE.MeshBasicMaterial({ color: color });
                const core = new THREE.Mesh(coreGeo, coreMat);
                mesh.add(core);
            } 
            else if (type === "microverse") {
                // Icosahedron with energy field
                const geo = new THREE.IcosahedronGeometry(1.3 * scale, 1);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color,
                    wireframe: false,
                    roughness: 0.4,
                    metalness: 0.6,
                    emissive: color,
                    emissiveIntensity: 0.3
                });
                mesh = new THREE.Mesh(geo, mat);
                
                // Add wireframe overlay
                const wireGeo = new THREE.IcosahedronGeometry(1.4 * scale, 1);
                const wireMat = new THREE.MeshBasicMaterial({ 
                    color: color, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.4
                });
                const wire = new THREE.Mesh(wireGeo, wireMat);
                mesh.add(wire);
            }
            else if (type === "dimension") {
                // Dodecahedron for alternate dimensions
                const geo = new THREE.DodecahedronGeometry(1.4 * scale, 0);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    roughness: 0.7, 
                    metalness: 0.3,
                    emissive: color,
                    emissiveIntensity: 0.15
                });
                mesh = new THREE.Mesh(geo, mat);
            }
            else {
                // Enhanced planet with atmosphere
                const geo = new THREE.SphereGeometry(1.4 * scale, 24, 24);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    roughness: 0.8, 
                    metalness: 0.2
                });
                mesh = new THREE.Mesh(geo, mat);
                
                // Add atmosphere glow
                const glowGeo = new THREE.SphereGeometry(1.55 * scale, 24, 24);
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                mesh.add(glow);
            }
            
            return mesh;
        }

        // Add custom locations
        customLocations.forEach(loc => {
            const obj = getShapeForType(loc.shape, loc.color, loc.scale);
            obj.position.set(loc.position.x, loc.position.y, loc.position.z);
            
            obj.userData = {
                name: loc.name,
                type: loc.type,
                dimension: loc.dimension,
                residents: [],
                description: loc.description,
                threat: loc.threat
            };

            scene.add(obj);
            interactables.push(obj);
        });

        // Fetch API locations and integrate them
        async function fetchUniverse() {
            try {
                const page1 = fetch('https://rickandmortyapi.com/api/location?page=1').then(r => r.json());
                const page2 = fetch('https://rickandmortyapi.com/api/location?page=2').then(r => r.json());
                const page3 = fetch('https://rickandmortyapi.com/api/location?page=3').then(r => r.json());
                const page4 = fetch('https://rickandmortyapi.com/api/location?page=4').then(r => r.json());

                const results = await Promise.all([page1, page2, page3, page4]);
                const locations = [...results[0].results, ...results[1].results, ...results[2].results, ...results[3].results];

                document.getElementById('loading-overlay').style.opacity = 0;
                setTimeout(() => document.getElementById('loading-overlay').style.display = 'none', 1000);

                let angle = 0;
                let layer = 0;
                let itemsInLayer = 0;
                const itemsPerLayer = 12;

                locations.forEach((loc, index) => {
                    if (loc.name.includes("Citadel")) return; 

                    // Skip if we already have this as a custom location
                    if (customLocations.some(custom => custom.name === loc.name)) return;

                    let colorHex, shapeType;
                    switch(loc.type) {
                        case 'Planet': 
                            colorHex = 0x3498db; 
                            shapeType = 'planet';
                            break;
                        case 'Cluster': 
                            colorHex = 0x9b59b6; 
                            shapeType = 'dimension';
                            break;
                        case 'Space Station': 
                            colorHex = 0x95a5a6; 
                            shapeType = 'station';
                            break;
                        case 'Microverse': 
                            colorHex = 0xe74c3c; 
                            shapeType = 'microverse';
                            break;
                        case 'TV': 
                            colorHex = 0xf1c40f;
                            shapeType = 'dimension';
                            break; 
                        default: 
                            colorHex = 0x2ecc71;
                            shapeType = 'planet';
                    }

                    const obj = getShapeForType(shapeType, colorHex);

                    // Spiral positioning
                    if (itemsInLayer >= itemsPerLayer) {
                        layer++;
                        itemsInLayer = 0;
                    }

                    const radius = 50 + layer * 15;
                    angle += (Math.PI * 2) / itemsPerLayer;
                    
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 8;
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 8;
                    const y = (Math.random() - 0.5) * (radius * 0.4);

                    obj.position.set(x, y, z);
                    
                    obj.userData = {
                        name: loc.name,
                        type: loc.type,
                        dimension: loc.dimension,
                        residents: loc.residents,
                        description: `A ${loc.type.toLowerCase()} in dimension ${loc.dimension}. Further details classified.`,
                        threat: "UNKNOWN"
                    };

                    scene.add(obj);
                    interactables.push(obj);
                    
                    itemsInLayer++;
                });

            } catch (err) {
                console.error("API Error", err);
                document.getElementById('loading-overlay').style.opacity = 0;
                setTimeout(() => document.getElementById('loading-overlay').style.display = 'none', 1000);
            }
        }

        fetchUniverse();

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedObject = null;

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables, true);

            if (intersects.length > 0) {
                const target = intersects[0].object;
                const userData = target.userData.name ? target.userData : target.parent.userData;
                
                if(selectedObject && selectedObject !== target && !selectedObject.userData.isCitadel) {
                    if(selectedObject.material && selectedObject.material.emissive) {
                        selectedObject.material.emissive.setHex(0x000000);
                    }
                }
                
                selectedObject = target;
                if(!userData.isCitadel && target.material && target.material.emissive) {
                    target.material.emissive.setHex(0x444444);
                }
                
                updateUI(userData);
                controls.autoRotate = false;
            } else {
                controls.autoRotate = true;
                document.getElementById('scanner-modal').style.display = 'none';
            }
        });

        async function updateUI(data) {
            const modal = document.getElementById('scanner-modal');
            const list = document.getElementById('res-list');
            
            modal.style.display = 'block';
            document.getElementById('info-name').innerText = data.name;
            document.getElementById('info-type').innerText = data.type;
            document.getElementById('info-dim').innerText = data.dimension;
            document.getElementById('info-threat').innerText = data.threat || "UNKNOWN";
            document.getElementById('info-desc').innerText = data.description || "No additional data available.";
            document.getElementById('info-pop').innerText = data.residents.length > 0 ? data.residents.length + " Lifeforms" : "Uninhabited";

            list.innerHTML = '<li>âš¡ Accessing biometric database...</li>';

            if (data.residents.length === 0) {
                list.innerHTML = '<li>âš  No lifeforms detected.</li>';
                return;
            }

            const residentUrls = data.residents.slice(0, 6);
            try {
                const fetches = residentUrls.map(url => fetch(url).then(res => res.json()));
                const residents = await Promise.all(fetches);
                
                list.innerHTML = '';
                residents.forEach(char => {
                    const li = document.createElement('li');
                    const statusIcon = char.status === 'Alive' ? 'ðŸŸ¢' : char.status === 'Dead' ? 'ðŸ”´' : 'ðŸŸ¡';
                    li.innerText = `${statusIcon} ${char.name} (${char.species})`;
                    list.appendChild(li);
                });
                
                if (data.residents.length > 6) {
                    const more = document.createElement('li');
                    more.style.fontStyle = 'italic';
                    more.style.opacity = '0.7';
                    more.innerText = `...and ${data.residents.length - 6} others`;
                    list.appendChild(more);
                }

            } catch (e) {
                list.innerHTML = '<li>âš  Database Encryption Error.</li>';
            }
        }

        // Animate objects
        const animatedObjects = [];
        scene.traverse((object) => {
            if (object.isMesh && object !== citadel && object.parent !== citadel) {
                animatedObjects.push({
                    mesh: object,
                    rotationSpeed: {
                        x: (Math.random() - 0.5) * 0.01,
                        y: (Math.random() - 0.5) * 0.01,
                        z: (Math.random() - 0.5) * 0.01
                    },
                    bobSpeed: Math.random() * 0.5 + 0.5,
                    bobAmount: Math.random() * 0.3 + 0.1,
                    initialY: object.position.y
                });
            }
        });

        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.01;
            
            // Rotate citadel
            citadel.rotation.y += 0.001;
            
            // Animate other objects
            animatedObjects.forEach((obj) => {
                obj.mesh.rotation.x += obj.rotationSpeed.x;
                obj.mesh.rotation.y += obj.rotationSpeed.y;
                obj.mesh.rotation.z += obj.rotationSpeed.z;
                
                // Floating effect
                obj.mesh.position.y = obj.initialY + Math.sin(time * obj.bobSpeed) * obj.bobAmount;
            });
            
            // Pulse portal light
            portalLight.intensity = 4 + Math.sin(time * 2) * 0.5;
            
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
