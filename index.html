<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interdimensional Cartography System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
            color: #00ff00;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #00ff00;
            padding: 15px;
            font-size: 12px;
            max-width: 350px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        @media (max-width: 768px) {
            #hud {
                font-size: 10px;
                max-width: 250px;
                padding: 10px;
            }
        }
        
        @media (max-width: 480px) {
            #hud {
                font-size: 9px;
                max-width: 180px;
                padding: 8px;
                top: 10px;
                left: 10px;
            }
        }
        
        #hud h2 {
            color: #00ffff;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #dimension-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 50, 0, 0.5);
            border-left: 3px solid #00ff00;
        }
        
        .dimension-label {
            color: #ffff00;
            font-weight: bold;
        }
        
        .status {
            color: #00ff00;
            animation: blink 1.5s infinite;
        }
        
        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.5; }
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #00ff00;
            padding: 15px;
            font-size: 11px;
            z-index: 100;
        }
        
        @media (max-width: 768px) {
            #controls {
                font-size: 9px;
                padding: 10px;
                bottom: 10px;
                left: 10px;
            }
        }
        
        @media (max-width: 480px) {
            #controls {
                font-size: 8px;
                padding: 8px;
                max-width: 180px;
            }
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 10px;
            font-size: 11px;
            pointer-events: none;
            display: none;
            z-index: 200;
            max-width: 300px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }
        
        .threat-level {
            display: inline-block;
            padding: 2px 6px;
            margin-left: 5px;
            border-radius: 3px;
            font-size: 10px;
        }
        
        .threat-low { background: #00ff00; color: #000; }
        .threat-medium { background: #ffff00; color: #000; }
        .threat-high { background: #ff6600; color: #000; }
        .threat-extreme { background: #ff0000; color: #fff; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="hud">
        <h2>INTERDIMENSIONAL CARTOGRAPHY</h2>
        <div>Status: <span class="status">ONLINE</span></div>
        <div>Portal Gun Charge: <span id="charge">100%</span></div>
        <div>Dimensions Mapped: <span id="dim-count">0</span></div>
        <div id="dimension-info">
            <div class="dimension-label">Select a dimension to view details</div>
        </div>
    </div>
    
    <div id="controls">
        <strong>CONTROLS:</strong><br>
        <strong>Desktop:</strong><br>
        • Click & Drag: Rotate view<br>
        • Mouse Wheel: Zoom<br>
        • Click Dimension: View details<br>
        • Space: Random portal<br>
        <strong>Tablet/Touch:</strong><br>
        • One Finger: Rotate view<br>
        • Pinch: Zoom in/out<br>
        • Tap Dimension: View details
    </div>
    
    <div id="tooltip" class="tooltip"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Lore-accurate Rick and Morty dimensions
        const dimensions = [
            {
                name: "C-137",
                designation: "C-137",
                description: "Rick's original dimension. Currently abandoned after Cronenberg incident.",
                threat: "extreme",
                color: 0xff0000,
                position: [0, 0, 0],
                size: 1.2,
                features: ["Cronenberged", "Abandoned", "Original Rick"]
            },
            {
                name: "Replacement Dimension",
                designation: "Unknown",
                description: "Current home dimension of Rick C-137 and Morty after dimension hop.",
                threat: "medium",
                color: 0x00ff00,
                position: [3, 1, 2],
                size: 1.0,
                features: ["Current Home", "Dead Rick & Morty Buried"]
            },
            {
                name: "Citadel Dimension",
                designation: "Citadel",
                description: "Home to the Citadel of Ricks. Governmental center of the multiverse.",
                threat: "high",
                color: 0xffaa00,
                position: [-4, 2, -1],
                size: 1.5,
                features: ["Political Center", "Corrupted", "Simple Rick's"]
            },
            {
                name: "Dimension J19ζ7",
                designation: "J19ζ7",
                description: "Doofus Rick's dimension. Technology developed without weapons.",
                threat: "low",
                color: 0x00aaff,
                position: [2, -3, 4],
                size: 0.9,
                features: ["Peaceful", "Doofus Rick", "Ovenless Brownies"]
            },
            {
                name: "Dimension 35-C",
                designation: "35-C",
                description: "The dimension where Pizza is a phone topping and phones are eaten.",
                threat: "low",
                color: 0xff00ff,
                position: [-3, -2, 3],
                size: 0.8,
                features: ["Pizza Phones", "Harmless Oddity"]
            },
            {
                name: "Dimension C-500A",
                designation: "C-500A",
                description: "Dimension where chairs are people and people are chairs.",
                threat: "medium",
                color: 0xffff00,
                position: [5, 0, -3],
                size: 0.85,
                features: ["Chair People", "Existential Crisis Inducing"]
            },
            {
                name: "Fascist Dimension",
                designation: "Unknown",
                description: "Dimension controlled by fascist Morty. High military presence.",
                threat: "extreme",
                color: 0x880000,
                position: [-5, -1, -4],
                size: 1.1,
                features: ["Fascist Morty", "Militarized", "Dangerous"]
            },
            {
                name: "Dimension K-83",
                designation: "K-83",
                description: "Dimension with time-frozen entities and temporal anomalies.",
                threat: "high",
                color: 0x00ffff,
                position: [4, 3, 1],
                size: 0.95,
                features: ["Time Anomalies", "Frozen Entities"]
            },
            {
                name: "Hamster in Butt World",
                designation: "Unknown",
                description: "Dimension where humans have hamsters living in their rectums.",
                threat: "low",
                color: 0xaa6600,
                position: [1, -4, -2],
                size: 0.75,
                features: ["Hamsters in Butts", "Weird but Harmless"]
            },
            {
                name: "Dimension D-99",
                designation: "D-99",
                description: "Dimension where Jerry is successful and confident.",
                threat: "low",
                color: 0xff6699,
                position: [-2, 3, 5],
                size: 0.8,
                features: ["Successful Jerry", "Statistical Anomaly"]
            },
            {
                name: "Anatomy Park Dimension",
                designation: "Unknown",
                description: "Location of miniaturization technology. Disease research center.",
                threat: "medium",
                color: 0xff3300,
                position: [3, 2, -4],
                size: 0.9,
                features: ["Miniaturization Tech", "Anatomy Park"]
            },
            {
                name: "Blender Dimension",
                designation: "5-126",
                description: "Dimension consisting entirely of blended matter and screaming.",
                threat: "extreme",
                color: 0x990099,
                position: [-4, -3, 2],
                size: 1.0,
                features: ["Everything Blended", "Constant Screaming", "DO NOT VISIT"]
            },
            {
                name: "Interdimensional Customs",
                designation: "Customs",
                description: "Bureaucratic checkpoint between major dimensional clusters.",
                threat: "medium",
                color: 0x666666,
                position: [0, 4, 0],
                size: 1.3,
                features: ["Bureaucracy", "Checkpoint", "Seeds Illegal"]
            },
            {
                name: "Dimension C-132",
                designation: "C-132",
                description: "Dimension where Rick turned himself into a pickle.",
                threat: "low",
                color: 0x00ff66,
                position: [2, 1, -5],
                size: 0.85,
                features: ["Pickle Rick Incident", "Rat Sewer Battle"]
            },
            {
                name: "Froopyland",
                designation: "Froopy",
                description: "Pocket dimension created by Rick. Beth's imaginary land made real.",
                threat: "high",
                color: 0xff99ff,
                position: [-1, -2, -3],
                size: 0.7,
                features: ["Pocket Dimension", "Cannibalistic Tommy", "Beth's Creation"]
            },
            {
                name: "Galactic Federation HQ",
                designation: "Fed-1",
                description: "Former seat of Galactic Federation power. Now dissolved.",
                threat: "low",
                color: 0x0066ff,
                position: [6, -2, 0],
                size: 1.2,
                features: ["Post-Collapse", "Former Federation", "Rick Destroyed"]
            },
            {
                name: "Purge Planet",
                designation: "Unknown",
                description: "Planet with annual purge festival. Extreme violence.",
                threat: "extreme",
                color: 0xff0066,
                position: [-6, 1, -2],
                size: 0.95,
                features: ["Annual Purge", "Lighthouse Incident", "Very Dangerous"]
            },
            {
                name: "Gear World",
                designation: "Gear",
                description: "Dimension inhabited by sentient gears. Gearhead's home.",
                threat: "low",
                color: 0xcccccc,
                position: [3, -1, 3],
                size: 0.8,
                features: ["Gear People", "Revolio Clockberg Jr.", "Mechanical"]
            },
            {
                name: "Zigerion Homeworld",
                designation: "Unknown",
                description: "Scammer aliens attempting to steal Rick's portal formula.",
                threat: "low",
                color: 0xff6600,
                position: [-3, 4, 1],
                size: 0.75,
                features: ["Zigerion Scammers", "Simulation Obsessed", "Nudity Culture"]
            },
            {
                name: "Unity's Dimension",
                designation: "Unknown",
                description: "Dimension controlled by hivemind entity Unity.",
                threat: "medium",
                color: 0x9966ff,
                position: [4, -4, -1],
                size: 1.1,
                features: ["Hivemind Unity", "Rick's Ex", "Total Assimilation"]
            },
            {
                name: "Microverse Battery",
                designation: "Microverse",
                description: "Miniature universe inside Rick's car battery. Powers his ship.",
                threat: "medium",
                color: 0xff9900,
                position: [-2, -4, 4],
                size: 0.6,
                features: ["Miniverse Inside", "Slave Labor", "Zigerion's Planet"]
            },
            {
                name: "Dimension of Shrimp Colors",
                designation: "Unknown",
                description: "Dimension where mantis shrimp-like beings see more colors.",
                threat: "low",
                color: 0xff00aa,
                position: [5, 4, 2],
                size: 0.7,
                features: ["16 Primary Colors", "Incomprehensible Hues"]
            },
            {
                name: "Gazorpazorp",
                designation: "Gazorp",
                description: "Matriarchal society. Males are violent and primitive.",
                threat: "high",
                color: 0xff3399,
                position: [-5, 3, -3],
                size: 1.0,
                features: ["Morty Jr.", "Matriarchy", "Sex Robot Origin"]
            },
            {
                name: "Pluto",
                designation: "Pluto",
                description: "Mining colony. Believes it's still a planet.",
                threat: "low",
                color: 0x8888ff,
                position: [6, 2, -4],
                size: 0.9,
                features: ["Plutonium Mining", "Planet Denial", "Scroopy Noopers"]
            },
            {
                name: "Alphabetrium",
                designation: "Alpha-7",
                description: "Dimension where alphabet is different. Letters are alive.",
                threat: "low",
                color: 0xffaa55,
                position: [-6, -2, 1],
                size: 0.75,
                features: ["Living Letters", "Linguistic Anomaly"]
            },
            {
                name: "Cronenberg World",
                designation: "Cron-1",
                description: "Dimension overrun by Cronenberg monsters. Several exist.",
                threat: "extreme",
                color: 0x884444,
                position: [0, -5, -4],
                size: 1.1,
                features: ["Failed Love Potion", "Body Horror", "Multiple Versions"]
            },
            {
                name: "Bird World",
                designation: "Bird-1",
                description: "Birdperson's home dimension. Site of the wedding massacre.",
                threat: "high",
                color: 0x00aa88,
                position: [7, 0, 3],
                size: 1.0,
                features: ["Phoenixperson", "Wedding Massacre", "Tammy's Betrayal"]
            },
            {
                name: "Dimension of Giants",
                designation: "Giant",
                description: "Everything is giant-sized including people and objects.",
                threat: "medium",
                color: 0xaa88ff,
                position: [-7, 1, 0],
                size: 1.4,
                features: ["Giant Everything", "Scale Anomaly"]
            },
            {
                name: "Jerryboree",
                designation: "Jerry-Care",
                description: "Daycare facility for Jerrys across infinite dimensions.",
                threat: "low",
                color: 0xffcc99,
                position: [2, 5, -1],
                size: 0.85,
                features: ["Jerry Daycare", "Infinite Jerrys", "Safe Zone"]
            },
            {
                name: "Testicle Monster Dimension",
                designation: "Unknown",
                description: "Dimension populated by aggressive testicle monsters.",
                threat: "high",
                color: 0xcc6699,
                position: [-3, -5, -1],
                size: 0.9,
                features: ["Testicle Monsters", "Hostile", "Bizarre Biology"]
            },
            {
                name: "Vindicators HQ",
                designation: "Vindi-1",
                description: "Home base of the Vindicators superhero team.",
                threat: "medium",
                color: 0x0099ff,
                position: [4, -5, 3],
                size: 1.0,
                features: ["Superhero Team", "Drunk Rick's Revenge", "Million Ants"]
            },
            {
                name: "Worldender's Dimension",
                designation: "W-End",
                description: "Former domain of Worldender before his defeat.",
                threat: "low",
                color: 0x666699,
                position: [-4, 5, 2],
                size: 0.8,
                features: ["Post-Worldender", "Vindicators Mission", "Destroyed"]
            },
            {
                name: "Morty's Mind Blowers",
                designation: "Memory",
                description: "Memory storage dimension. Contains erased Morty memories.",
                threat: "medium",
                color: 0xff66ff,
                position: [5, -3, -5],
                size: 0.7,
                features: ["Memory Storage", "Truth Serum", "Squirrels"]
            },
            {
                name: "Atlantis",
                designation: "Atlant",
                description: "Underwater dimension. Technologically advanced but petty.",
                threat: "low",
                color: 0x0066aa,
                position: [-1, 5, 4],
                size: 0.95,
                features: ["Underwater City", "Mer-People", "Rick Hates It"]
            },
            {
                name: "Interdimensional Cable Origin",
                designation: "IC-Prime",
                description: "Source dimension of interdimensional cable technology.",
                threat: "low",
                color: 0xaa00aa,
                position: [3, 3, 5],
                size: 0.75,
                features: ["Infinite TV", "Ball Fondlers", "Jan Quadrant Vincent"]
            },
            {
                name: "Death Crystal Dimension",
                designation: "D-Cry",
                description: "Source of death crystals. Shows infinite death possibilities.",
                threat: "high",
                color: 0xff0099,
                position: [-5, -4, 5],
                size: 0.85,
                features: ["Death Crystals", "Akira Slide", "Holographic Projection"]
            },
            {
                name: "Story Train",
                designation: "Story",
                description: "Narrative-driven dimension with literal story structure.",
                threat: "medium",
                color: 0x9999ff,
                position: [6, -4, -2],
                size: 0.9,
                features: ["Meta-Narrative", "Story Lord", "Anthology"]
            },
            {
                name: "Vat of Acid",
                designation: "Acid",
                description: "Location of the famous fake vat of acid.",
                threat: "low",
                color: 0x99ff00,
                position: [-6, 4, -4],
                size: 0.75,
                features: ["Fake Acid", "Save Points", "Morty's Girlfriends"]
            },
            {
                name: "Heist-Con",
                designation: "Heist",
                description: "Dimension devoted to heist culture and conventions.",
                threat: "low",
                color: 0xff6633,
                position: [7, 3, -1],
                size: 0.8,
                features: ["Heist Culture", "Mr. Poopybutthole", "Randotron"]
            },
            {
                name: "Planet Squanch",
                designation: "Squanch",
                description: "Squanchy's home planet. Heavy partying culture.",
                threat: "low",
                color: 0xff9966,
                position: [1, -6, 0],
                size: 0.85,
                features: ["Squanchy's Home", "Party Planet", "Squanch Language"]
            }
        ];
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x001a0d); // Dark green tint like the show
        scene.fog = new THREE.Fog(0x001a0d, 15, 50);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        camera.position.y = 5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting - cyan/green sci-fi lighting like the show
        const ambientLight = new THREE.AmbientLight(0x003d29, 0.6);
        scene.add(ambientLight);
        
        const mainLight = new THREE.PointLight(0x00ff00, 1.5, 100);
        mainLight.position.set(10, 10, 10);
        scene.add(mainLight);
        
        const accentLight = new THREE.PointLight(0x00ffff, 0.8, 80);
        accentLight.position.set(-10, -10, 10);
        scene.add(accentLight);
        
        const backLight = new THREE.PointLight(0x0088ff, 0.5, 60);
        backLight.position.set(0, 5, -15);
        scene.add(backLight);
        
        // Create starfield with Rick and Morty style colors
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        const starColors = [];
        for (let i = 0; i < 3000; i++) {
            const x = (Math.random() - 0.5) * 200;
            const y = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 200;
            starVertices.push(x, y, z);
            
            // Mix of white, cyan, and green stars
            const colorChoice = Math.random();
            if (colorChoice < 0.6) {
                starColors.push(1, 1, 1); // white
            } else if (colorChoice < 0.8) {
                starColors.push(0, 1, 1); // cyan
            } else {
                starColors.push(0, 1, 0.5); // green-cyan
            }
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        const starMaterial = new THREE.PointsMaterial({ 
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        
        // Create dimension portals with Rick and Morty style
        const dimensionObjects = [];
        const portalLines = [];
        const portalRings = [];
        
        dimensions.forEach((dim, index) => {
            const group = new THREE.Group();
            group.position.set(...dim.position);
            group.userData = dim;
            
            // Create portal ring (the iconic green portal)
            const ringGeometry = new THREE.TorusGeometry(dim.size, dim.size * 0.15, 16, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            group.add(ring);
            
            // Inner portal glow (the liquid-like portal center)
            const portalGeometry = new THREE.CircleGeometry(dim.size * 0.95, 32);
            const portalMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.rotation.x = Math.PI / 2;
            group.add(portal);
            
            // Dimension indicator sphere (floating in portal)
            const sphereGeometry = new THREE.SphereGeometry(dim.size * 0.4, 16, 16);
            const sphereMaterial = new THREE.MeshToonMaterial({
                color: dim.color,
                emissive: dim.color,
                emissiveIntensity: 0.5
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.z = 0.3;
            group.add(sphere);
            
            // Outline for toon effect
            const outlineGeometry = new THREE.SphereGeometry(dim.size * 0.42, 16, 16);
            const outlineMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                side: THREE.BackSide
            });
            const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
            outline.position.z = 0.3;
            group.add(outline);
            
            // Portal particles/drips
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const particleGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                const radius = dim.size * 1.1;
                particle.position.x = Math.cos(angle) * radius;
                particle.position.y = Math.sin(angle) * radius;
                particle.position.z = (Math.random() - 0.5) * 0.3;
                particle.userData = { 
                    angle: angle, 
                    radius: radius,
                    speed: 0.02 + Math.random() * 0.03,
                    offset: Math.random() * Math.PI * 2
                };
                group.add(particle);
                portalRings.push(particle);
            }
            
            // Sci-fi tech rings around portal
            for (let i = 0; i < 3; i++) {
                const techRingGeometry = new THREE.TorusGeometry(
                    dim.size * (1.3 + i * 0.15), 
                    0.02, 
                    8, 
                    24
                );
                const techRingMaterial = new THREE.MeshBasicMaterial({
                    color: dim.threat === 'extreme' ? 0xff0000 : 0x00ffff,
                    transparent: true,
                    opacity: 0.4
                });
                const techRing = new THREE.Mesh(techRingGeometry, techRingMaterial);
                techRing.rotation.x = Math.PI / 2;
                techRing.userData = { 
                    rotationSpeed: 0.001 * (i + 1) * (i % 2 === 0 ? 1 : -1)
                };
                group.add(techRing);
                portalRings.push(techRing);
            }
            
            scene.add(group);
            dimensionObjects.push(group);
            
            // Add label with Rick and Morty font style
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            // Background
            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Border
            context.strokeStyle = '#00ff00';
            context.lineWidth = 4;
            context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
            
            // Text
            context.fillStyle = '#00ff00';
            context.font = 'Bold 36px Arial';
            context.textAlign = 'center';
            context.fillText(dim.designation, 256, 50);
            
            context.fillStyle = dim.threat === 'extreme' ? '#ff0000' : 
                               dim.threat === 'high' ? '#ff6600' :
                               dim.threat === 'medium' ? '#ffff00' : '#00ff00';
            context.font = 'Bold 24px Arial';
            context.fillText(`[${dim.threat.toUpperCase()}]`, 256, 85);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true 
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4, 1, 1);
            sprite.position.y = dim.size + 1.5;
            group.add(sprite);
        });
        
        // Create portal connections (animated green energy beams like portal gun)
        const connections = [
            [0, 1], // C-137 to Replacement
            [1, 2], // Replacement to Citadel
            [2, 12], // Citadel to Customs
            [0, 6], // C-137 to Fascist
            [1, 13], // Replacement to Pickle dimension
            [2, 3], // Citadel to Doofus Rick
            [15, 2], // Galactic Fed to Citadel
            [19, 1], // Unity to Replacement
            [2, 28], // Citadel to Jerryboree
            [20, 1], // Microverse to Replacement
            [22, 2], // Gazorpazorp to Citadel
            [14, 1], // Froopyland to Replacement
            [26, 19], // Bird World to Unity
            [30, 2], // Vindicators to Citadel
            [0, 25], // C-137 to Cronenberg World
            [21, 3], // Shrimp Colors to Doofus Rick
            [35, 10], // Death Crystal to Anatomy Park
            [12, 15], // Customs to Galactic Fed
            [23, 15], // Pluto to Galactic Fed
            [27, 6], // Giants to Fascist
            [33, 1], // Atlantis to Replacement
            [34, 2], // Interdimensional Cable to Citadel
            [36, 1], // Story Train to Replacement
            [38, 2], // Heist-Con to Citadel
            [39, 19], // Planet Squanch to Unity
        ];
        
        connections.forEach(([i, j]) => {
            const start = dimensionObjects[i].position;
            const end = dimensionObjects[j].position;
            
            // Main beam
            const points = [start, end];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            portalLines.push(line);
            
            // Energy particles along the beam
            for (let k = 0; k < 5; k++) {
                const t = k / 5;
                const particlePos = new THREE.Vector3(
                    start.x + (end.x - start.x) * t,
                    start.y + (end.y - start.y) * t,
                    start.z + (end.z - start.z) * t
                );
                
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(particlePos);
                particle.userData = {
                    startPos: start,
                    endPos: end,
                    progress: t,
                    speed: 0.01 + Math.random() * 0.01
                };
                scene.add(particle);
                portalRings.push(particle);
            }
        });
        
        // Mouse and Touch interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        const dimensionInfo = document.getElementById('dimension-info');
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let selectedDimension = null;
        
        // Touch controls for tablets
        let touchStartDistance = 0;
        let initialCameraZ = camera.position.z;
        let isTouching = false;
        
        // Mouse events
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        renderer.domElement.addEventListener('mousemove', handleMove);
        
        // Touch events for tablets
        renderer.domElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isTouching = true;
            
            if (e.touches.length === 1) {
                // Single touch - rotation
                previousMousePosition = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
            } else if (e.touches.length === 2) {
                // Two finger pinch - zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                initialCameraZ = camera.position.z;
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch - rotate
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;
                
                camera.position.x += deltaX * 0.02;
                camera.position.y -= deltaY * 0.02;
                
                camera.lookAt(scene.position);
                
                previousMousePosition = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
            } else if (e.touches.length === 2) {
                // Two finger pinch - zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const scale = touchStartDistance / distance;
                camera.position.z = initialCameraZ * scale;
                camera.position.z = Math.max(5, Math.min(30, camera.position.z));
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                isTouching = false;
                
                // Check for tap on dimension
                if (e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(dimensionObjects);
                    
                    if (intersects.length > 0) {
                        // Reset previous selection
                        if (selectedDimension) {
                            selectedDimension.children.forEach(child => {
                                if (child.material && child.material.emissiveIntensity !== undefined) {
                                    child.material.emissiveIntensity = 0.5;
                                }
                            });
                        }
                        
                        selectedDimension = intersects[0].object.parent;
                        selectedDimension.children.forEach(child => {
                            if (child.material && child.material.emissiveIntensity !== undefined) {
                                child.material.emissiveIntensity = 1.0;
                            }
                        });
                        
                        const dim = selectedDimension.userData;
                        const threatClass = `threat-${dim.threat}`;
                        
                        dimensionInfo.innerHTML = `
                            <div class="dimension-label">${dim.name}</div>
                            <div><strong>Designation:</strong> ${dim.designation}</div>
                            <div><strong>Threat Level:</strong> <span class="threat-level ${threatClass}">${dim.threat.toUpperCase()}</span></div>
                            <div><strong>Description:</strong> ${dim.description}</div>
                            <div><strong>Notable Features:</strong></div>
                            <div style="margin-left: 10px;">
                                ${dim.features.map(f => `• ${f}`).join('<br>')}
                            </div>
                        `;
                    }
                }
            }
        });
        
        function handleMove(e) {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                camera.position.x += deltaX * 0.01;
                camera.position.y -= deltaY * 0.01;
                
                camera.lookAt(scene.position);
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
            
            // Update mouse position for raycasting
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            // Check for hover (desktop only)
            if (!isTouching) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(dimensionObjects, true);
                
                if (intersects.length > 0) {
                    const topObject = intersects[0].object;
                    const group = topObject.parent.userData ? topObject.parent : topObject;
                    const dim = group.userData || topObject.userData;
                    
                    if (dim && dim.name) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 15 + 'px';
                        tooltip.style.top = e.clientY + 15 + 'px';
                        
                        const threatClass = `threat-${dim.threat}`;
                        tooltip.innerHTML = `
                            <strong style="color: #00ffff;">${dim.name}</strong>
                            <span class="threat-level ${threatClass}">${dim.threat.toUpperCase()}</span><br>
                            <em>${dim.designation}</em><br>
                            ${dim.description}
                        `;
                        
                        // Highlight on hover
                        if (topObject.material && topObject.material.emissiveIntensity !== undefined) {
                            topObject.material.emissiveIntensity = 0.8;
                        }
                    }
                } else {
                    tooltip.style.display = 'none';
                    dimensionObjects.forEach(group => {
                        if (group !== selectedDimension) {
                            group.children.forEach(child => {
                                if (child.material && child.material.emissiveIntensity !== undefined) {
                                    child.material.emissiveIntensity = 0.5;
                                }
                            });
                        }
                    });
                }
            }
        }
        
        renderer.domElement.addEventListener('click', (e) => {
            // Skip if this was a touch event (already handled)
            if (isTouching) return;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(dimensionObjects, true);
            
            if (intersects.length > 0) {
                // Reset previous selection
                if (selectedDimension) {
                    selectedDimension.children.forEach(child => {
                        if (child.material && child.material.emissiveIntensity !== undefined) {
                            child.material.emissiveIntensity = 0.5;
                        }
                    });
                }
                
                // Find the parent group
                const topObject = intersects[0].object;
                selectedDimension = topObject.parent.userData ? topObject.parent : topObject;
                
                // Highlight selection
                selectedDimension.children.forEach(child => {
                    if (child.material && child.material.emissiveIntensity !== undefined) {
                        child.material.emissiveIntensity = 1.0;
                    }
                });
                
                const dim = selectedDimension.userData;
                const threatClass = `threat-${dim.threat}`;
                
                dimensionInfo.innerHTML = `
                    <div class="dimension-label">${dim.name}</div>
                    <div><strong>Designation:</strong> ${dim.designation}</div>
                    <div><strong>Threat Level:</strong> <span class="threat-level ${threatClass}">${dim.threat.toUpperCase()}</span></div>
                    <div><strong>Description:</strong> ${dim.description}</div>
                    <div><strong>Notable Features:</strong></div>
                    <div style="margin-left: 10px;">
                        ${dim.features.map(f => `• ${f}`).join('<br>')}
                    </div>
                `;
            }
        });
        
        // Zoom with mouse wheel
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(5, Math.min(30, camera.position.z));
        });
        
        // Random portal on spacebar - Rick's portal gun effect
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                const randomDim = dimensionObjects[Math.floor(Math.random() * dimensionObjects.length)];
                
                // Create portal opening effect
                const portalFlash = new THREE.PointLight(0x00ff00, 5, 25);
                portalFlash.position.copy(randomDim.position);
                scene.add(portalFlash);
                
                // Create expanding portal ring
                const flashRingGeometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
                const flashRingMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 1
                });
                const flashRing = new THREE.Mesh(flashRingGeometry, flashRingMaterial);
                flashRing.position.copy(randomDim.position);
                flashRing.rotation.x = Math.PI / 2;
                scene.add(flashRing);
                
                // Create portal liquid splash particles
                const splashParticles = [];
                for (let i = 0; i < 20; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 1
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.copy(randomDim.position);
                    
                    const angle = (i / 20) * Math.PI * 2;
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            Math.cos(angle) * 0.1,
                            Math.sin(angle) * 0.1,
                            (Math.random() - 0.5) * 0.1
                        )
                    };
                    scene.add(particle);
                    splashParticles.push(particle);
                }
                
                // Animate portal opening
                let frame = 0;
                const portalAnimation = setInterval(() => {
                    frame++;
                    
                    // Expand and fade ring
                    const scale = 1 + frame * 0.3;
                    flashRing.scale.set(scale, scale, scale);
                    flashRing.material.opacity = 1 - (frame / 20);
                    
                    // Move and fade particles
                    splashParticles.forEach(p => {
                        p.position.add(p.userData.velocity);
                        p.material.opacity = 1 - (frame / 20);
                    });
                    
                    // Dim light
                    portalFlash.intensity = 5 - (frame / 4);
                    
                    if (frame >= 20) {
                        clearInterval(portalAnimation);
                        scene.remove(portalFlash);
                        scene.remove(flashRing);
                        splashParticles.forEach(p => scene.remove(p));
                    }
                }, 30);
                
                // Update HUD
                const charge = Math.floor(Math.random() * 40 + 60);
                document.getElementById('charge').textContent = charge + '%';
            }
        });
        
        // Update dimension count
        document.getElementById('dim-count').textContent = dimensions.length;
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Animate dimension portals
            dimensionObjects.forEach((group, i) => {
                // Rotate the entire portal group
                group.rotation.z += 0.01;
                
                // Get children for specific animations
                group.children.forEach((child, j) => {
                    // Animate portal ring
                    if (child.geometry && child.geometry.type === 'TorusGeometry' && j === 0) {
                        child.rotation.z += 0.02;
                        const pulse = Math.sin(time * 2 + i) * 0.1 + 1;
                        child.scale.set(pulse, pulse, 1);
                    }
                    
                    // Animate inner portal liquid effect
                    if (child.geometry && child.geometry.type === 'CircleGeometry') {
                        child.material.opacity = 0.5 + Math.sin(time * 3 + i) * 0.2;
                    }
                    
                    // Rotate dimension sphere
                    if (child.geometry && child.geometry.type === 'SphereGeometry' && j === 2) {
                        child.rotation.y += 0.02;
                        child.rotation.x += 0.01;
                    }
                });
                
                // Extreme threat dimensions pulse dramatically
                if (group.userData.threat === 'extreme') {
                    const dramaticPulse = Math.sin(time * 4) * 0.15 + 1;
                    group.scale.set(dramaticPulse, dramaticPulse, dramaticPulse);
                }
            });
            
            // Animate portal particles and tech rings
            portalRings.forEach((obj, i) => {
                if (obj.userData.angle !== undefined) {
                    // Portal drip particles
                    obj.userData.angle += obj.userData.speed;
                    const wobble = Math.sin(time * 2 + obj.userData.offset) * 0.1;
                    obj.position.x = Math.cos(obj.userData.angle) * (obj.userData.radius + wobble);
                    obj.position.y = Math.sin(obj.userData.angle) * (obj.userData.radius + wobble);
                    obj.position.z = Math.sin(time * 3 + i) * 0.3;
                    
                    // Pulse particle size
                    const scale = 0.8 + Math.sin(time * 4 + i) * 0.3;
                    obj.scale.set(scale, scale, scale);
                } else if (obj.userData.rotationSpeed !== undefined) {
                    // Tech rings rotation
                    obj.rotation.z += obj.userData.rotationSpeed;
                } else if (obj.userData.startPos !== undefined) {
                    // Energy beam particles
                    obj.userData.progress += obj.userData.speed;
                    if (obj.userData.progress > 1) {
                        obj.userData.progress = 0;
                    }
                    
                    const t = obj.userData.progress;
                    const start = obj.userData.startPos;
                    const end = obj.userData.endPos;
                    
                    obj.position.x = start.x + (end.x - start.x) * t;
                    obj.position.y = start.y + (end.y - start.y) * t;
                    obj.position.z = start.z + (end.z - start.z) * t;
                    
                    // Pulse along the beam
                    const pulseScale = Math.sin(t * Math.PI) * 0.5 + 0.5;
                    obj.scale.set(pulseScale, pulseScale, pulseScale);
                    obj.material.opacity = pulseScale;
                }
            });
            
            // Animate portal connection lines
            portalLines.forEach((line, i) => {
                line.material.opacity = 0.4 + Math.sin(time * 2 + i) * 0.2;
            });
            
            // Gentle camera movement
            camera.position.x += Math.sin(time * 0.2) * 0.002;
            camera.position.y += Math.cos(time * 0.15) * 0.002;
            camera.lookAt(scene.position);
            
            // Rotate starfield slowly
            stars.rotation.y += 0.0001;
            stars.rotation.x += 0.00005;
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
