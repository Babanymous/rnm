<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System - Rick's Database</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
            color: #00ff00;
            touch-action: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 12px;
            font-size: 11px;
            max-width: 320px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        #hud h2 {
            color: #00ffff;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #00ffff;
            font-size: 14px;
        }
        
        #celestial-info {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 50, 0, 0.5);
            border-left: 3px solid #00ff00;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .celestial-label {
            color: #ffff00;
            font-weight: bold;
        }
        
        .status {
            color: #00ff00;
            animation: blink 1.5s infinite;
        }
        
        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.5; }
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 10px;
            font-size: 10px;
            z-index: 100;
        }
        
        #view-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 10px;
            z-index: 100;
        }
        
        .view-btn {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 8px 12px;
            margin: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            transition: all 0.2s;
        }
        
        .view-btn:active, .view-btn.active {
            background: rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 8px;
            font-size: 10px;
            pointer-events: none;
            display: none;
            z-index: 200;
            max-width: 250px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }
        
        .type-tag {
            display: inline-block;
            padding: 2px 6px;
            margin-left: 5px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: bold;
        }
        
        .type-star { background: #ffff00; color: #000; }
        .type-planet { background: #0088ff; color: #fff; }
        .type-moon { background: #aaaaaa; color: #000; }
        .type-dwarf { background: #ff6600; color: #fff; }
        
        @media (max-width: 768px) {
            #hud {
                font-size: 9px;
                max-width: 220px;
                padding: 8px;
            }
            
            #hud h2 {
                font-size: 11px;
            }
            
            #controls {
                font-size: 8px;
                padding: 6px;
            }
            
            .view-btn {
                padding: 6px 10px;
                font-size: 9px;
                margin: 2px;
            }
            
            #view-controls {
                padding: 6px;
            }
        }
        
        @media (max-width: 480px) {
            #hud {
                font-size: 8px;
                max-width: 160px;
                padding: 6px;
            }
            
            #hud h2 {
                font-size: 10px;
            }
            
            #controls {
                font-size: 7px;
                padding: 5px;
                max-width: 140px;
            }
            
            .view-btn {
                padding: 5px 8px;
                font-size: 8px;
            }
            
            .tooltip {
                font-size: 8px;
                max-width: 180px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="hud">
        <h2>âš¡ SOLAR SYSTEM DATABASE âš¡</h2>
        <div>Status: <span class="status">ONLINE</span></div>
        <div>Objects: <span id="obj-count">0</span></div>
        <div>Portal Stability: <span class="status">98.7%</span></div>
        <div>Current View: <span id="current-view">Overview</span></div>
        <div id="celestial-info">
            <div class="celestial-label">ðŸ‘† Tap/Click any object</div>
            <div style="font-size: 9px; margin-top: 5px; color: #00ffff;">
                *burp* Don't touch Pluto, Morty. It's not even a real planet.
            </div>
        </div>
    </div>
    
    <div id="view-controls">
        <button class="view-btn active" onclick="setView('overview')">OVERVIEW</button><br>
        <button class="view-btn" onclick="setView('inner')">INNER SYSTEM</button><br>
        <button class="view-btn" onclick="setView('outer')">OUTER SYSTEM</button><br>
        <button class="view-btn" onclick="resetCamera()">RESET VIEW</button><br>
        <button class="view-btn" onclick="portalJump()" style="background: rgba(0, 255, 0, 0.3); margin-top: 10px;">ðŸŒ€ PORTAL JUMP</button>
    </div>
    
    <div id="controls">
        <strong>CONTROLS:</strong><br>
        <strong>Desktop:</strong><br>
        â€¢ Drag: Rotate<br>
        â€¢ Wheel: Zoom<br>
        â€¢ Click: Info<br>
        <strong>Touch:</strong><br>
        â€¢ 1 Finger: Rotate<br>
        â€¢ Pinch: Zoom<br>
        â€¢ Tap: Select
    </div>
    
    <div id="tooltip" class="tooltip"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Solar System data with major moons
        const solarSystemData = {
            sun: {
                name: "Sun",
                type: "star",
                radius: 3.0,
                color: 0xffff00,
                position: [0, 0, 0],
                info: "G-type main-sequence star. Powers the entire solar system.",
                facts: ["Mass: 1.989 Ã— 10^30 kg", "Temperature: 5,778 K", "Age: 4.6 billion years"]
            },
            planets: [
                {
                    name: "Mercury",
                    type: "planet",
                    radius: 0.38,
                    color: 0x8c7853,
                    distance: 8,
                    orbitSpeed: 0.024,
                    info: "Smallest planet. Closest to the Sun.",
                    facts: ["No moons", "No atmosphere", "Day length: 59 Earth days"],
                    moons: []
                },
                {
                    name: "Venus",
                    type: "planet",
                    radius: 0.95,
                    color: 0xffc649,
                    distance: 12,
                    orbitSpeed: 0.015,
                    info: "Hottest planet. Thick toxic atmosphere.",
                    facts: ["No moons", "Toxic atmosphere", "Rotates backwards"],
                    moons: []
                },
                {
                    name: "Earth",
                    type: "planet",
                    radius: 1.0,
                    color: 0x0077be,
                    distance: 16,
                    orbitSpeed: 0.01,
                    info: "Our home planet. Only known planet with life.",
                    facts: ["1 moon", "71% water coverage", "Supports life"],
                    moons: [
                        { name: "Moon", radius: 0.27, distance: 1.5, color: 0xaaaaaa, info: "Earth's only natural satellite" }
                    ]
                },
                {
                    name: "Mars",
                    type: "planet",
                    radius: 0.53,
                    color: 0xcd5c5c,
                    distance: 20,
                    orbitSpeed: 0.008,
                    info: "The Red Planet. Target for human colonization.",
                    facts: ["2 moons", "Largest volcano in solar system", "Polar ice caps"],
                    moons: [
                        { name: "Phobos", radius: 0.12, distance: 0.8, color: 0x999999, info: "Larger moon of Mars" },
                        { name: "Deimos", radius: 0.08, distance: 1.2, color: 0x888888, info: "Smaller moon of Mars" }
                    ]
                },
                {
                    name: "Jupiter",
                    type: "planet",
                    radius: 2.2,
                    color: 0xdaa520,
                    distance: 32,
                    orbitSpeed: 0.004,
                    info: "Largest planet. Gas giant with Great Red Spot.",
                    facts: ["95+ moons", "Strongest magnetic field", "Could fit 1,300 Earths"],
                    moons: [
                        { name: "Io", radius: 0.28, distance: 3.0, color: 0xffaa00, info: "Most volcanically active body" },
                        { name: "Europa", radius: 0.24, distance: 3.8, color: 0xccddff, info: "Subsurface ocean, potential life" },
                        { name: "Ganymede", radius: 0.41, distance: 4.6, color: 0xaaaaaa, info: "Largest moon in solar system" },
                        { name: "Callisto", radius: 0.37, distance: 5.4, color: 0x8b7355, info: "Heavily cratered surface" }
                    ]
                },
                {
                    name: "Saturn",
                    type: "planet",
                    radius: 1.8,
                    color: 0xfad5a5,
                    distance: 48,
                    orbitSpeed: 0.003,
                    info: "Gas giant with spectacular ring system.",
                    facts: ["146+ moons", "Iconic rings", "Least dense planet"],
                    moons: [
                        { name: "Titan", radius: 0.40, distance: 4.5, color: 0xff9944, info: "Only moon with dense atmosphere" },
                        { name: "Rhea", radius: 0.12, distance: 3.2, color: 0xcccccc, info: "Second largest moon of Saturn" },
                        { name: "Iapetus", radius: 0.11, distance: 5.8, color: 0x888888, info: "Two-toned coloration" },
                        { name: "Dione", radius: 0.09, distance: 2.8, color: 0xbbbbbb, info: "Icy surface with cliffs" },
                        { name: "Tethys", radius: 0.08, distance: 2.2, color: 0xdddddd, info: "Heavily cratered" },
                        { name: "Enceladus", radius: 0.04, distance: 1.8, color: 0xffffff, info: "Water geysers, potential life" },
                        { name: "Mimas", radius: 0.03, distance: 1.4, color: 0xaaaaaa, info: "Death Star lookalike" }
                    ]
                },
                {
                    name: "Uranus",
                    type: "planet",
                    radius: 1.3,
                    color: 0x4fd0e0,
                    distance: 64,
                    orbitSpeed: 0.002,
                    info: "Ice giant. Rotates on its side.",
                    facts: ["27+ moons", "Rotates sideways", "Methane atmosphere"],
                    moons: [
                        { name: "Titania", radius: 0.12, distance: 2.8, color: 0xaaaaaa, info: "Largest moon of Uranus" },
                        { name: "Oberon", radius: 0.11, distance: 3.4, color: 0x999999, info: "Heavily cratered" },
                        { name: "Umbriel", radius: 0.09, distance: 2.0, color: 0x777777, info: "Darkest moon" },
                        { name: "Ariel", radius: 0.09, distance: 1.6, color: 0xbbbbbb, info: "Brightest surface" },
                        { name: "Miranda", radius: 0.04, distance: 1.2, color: 0xcccccc, info: "Bizarre patchwork surface" }
                    ]
                },
                {
                    name: "Neptune",
                    type: "planet",
                    radius: 1.2,
                    color: 0x4169e1,
                    distance: 80,
                    orbitSpeed: 0.001,
                    info: "Farthest major planet. Fastest winds in solar system.",
                    facts: ["14+ moons", "Great Dark Spot", "Supersonic winds"],
                    moons: [
                        { name: "Triton", radius: 0.21, distance: 2.8, color: 0xffbbdd, info: "Largest moon, retrograde orbit" },
                        { name: "Proteus", radius: 0.08, distance: 3.5, color: 0x888888, info: "Irregular shape" },
                        { name: "Nereid", radius: 0.03, distance: 5.0, color: 0xaaaaaa, info: "Highly eccentric orbit" }
                    ]
                }
            ],
            dwarfPlanets: [
                {
                    name: "Pluto",
                    type: "dwarf",
                    radius: 0.18,
                    color: 0xc4a582,
                    distance: 96,
                    orbitSpeed: 0.0008,
                    info: "Former 9th planet. Dwarf planet in Kuiper Belt.",
                    facts: ["5 moons", "Heart-shaped region", "Still a planet to some"],
                    moons: [
                        { name: "Charon", radius: 0.095, distance: 0.9, color: 0xaaaaaa, info: "Half the size of Pluto" }
                    ]
                }
            ]
        };
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);
        scene.fog = new THREE.Fog(0x000510, 50, 200);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, 40, 80);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting
        const sunLight = new THREE.PointLight(0xffff00, 2, 300);
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);
        
        const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
        scene.add(ambientLight);
        
        // Create starfield
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        const starColors = [];
        for (let i = 0; i < 5000; i++) {
            const x = (Math.random() - 0.5) * 400;
            const y = (Math.random() - 0.5) * 400;
            const z = (Math.random() - 0.5) * 400;
            starVertices.push(x, y, z);
            
            const colorChoice = Math.random();
            if (colorChoice < 0.7) {
                starColors.push(1, 1, 1);
            } else if (colorChoice < 0.85) {
                starColors.push(0.5, 0.8, 1);
            } else {
                starColors.push(0.3, 1, 0.7);
            }
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        const starMaterial = new THREE.PointsMaterial({ 
            size: 0.2,
            vertexColors: true,
            transparent: true,
            opacity: 0.9
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        
        // Create celestial objects
        const celestialObjects = [];
        const orbitLines = [];
        let objectCount = 0;
        
        // Create Sun - Rick and Morty style
        const sunGroup = new THREE.Group();
        const sunGeometry = new THREE.SphereGeometry(solarSystemData.sun.radius, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: solarSystemData.sun.color,
            emissive: solarSystemData.sun.color,
            emissiveIntensity: 1
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.userData = solarSystemData.sun;
        
        // Multiple glowing layers for Rick and Morty sun effect
        for (let i = 1; i <= 3; i++) {
            const glowGeometry = new THREE.SphereGeometry(solarSystemData.sun.radius * (1 + i * 0.2), 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.3 / i,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.userData.glowLayer = i;
            sun.add(glow);
        }
        
        // Add energy particles around sun
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const particleGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            const radius = solarSystemData.sun.radius * 1.3;
            particle.position.x = Math.cos(angle) * radius;
            particle.position.y = Math.sin(angle) * radius;
            particle.userData.sunParticle = true;
            particle.userData.angle = angle;
            particle.userData.radius = radius;
            particle.userData.speed = 0.02 + Math.random() * 0.02;
            sun.add(particle);
        }
        
        sunGroup.add(sun);
        scene.add(sunGroup);
        celestialObjects.push(sunGroup);
        objectCount++;
        
        // Create planets with moons - Rick and Morty style
        solarSystemData.planets.forEach(planetData => {
            const planetGroup = new THREE.Group();
            
            // Create orbit line with portal effect
            const orbitGeometry = new THREE.BufferGeometry();
            const orbitPoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                orbitPoints.push(
                    Math.cos(angle) * planetData.distance,
                    0,
                    Math.sin(angle) * planetData.distance
                );
            }
            orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
            const orbitMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.4
            });
            const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
            orbitLine.userData.orbit = true;
            scene.add(orbitLine);
            orbitLines.push(orbitLine);
            
            // Create planet with cartoon shader
            const planetGeometry = new THREE.SphereGeometry(planetData.radius, 24, 24);
            const planetMaterial = new THREE.MeshToonMaterial({
                color: planetData.color,
                emissive: planetData.color,
                emissiveIntensity: 0.3
            });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            planet.userData = planetData;
            planet.userData.orbitDistance = planetData.distance;
            planet.userData.orbitSpeed = planetData.orbitSpeed;
            planet.userData.orbitAngle = Math.random() * Math.PI * 2;
            
            // Thick black outline for cartoon effect
            const outlineGeometry = new THREE.SphereGeometry(planetData.radius * 1.08, 24, 24);
            const outlineMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                side: THREE.BackSide
            });
            const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
            planet.add(outline);
            
            // Portal-like ring around planet
            const ringGeometry = new THREE.TorusGeometry(planetData.radius * 1.3, planetData.radius * 0.08, 16, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.userData.portalRing = true;
            planet.add(ring);
            
            // Dripping particles around planet
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const dripGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const dripMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.7
                });
                const drip = new THREE.Mesh(dripGeometry, dripMaterial);
                drip.position.x = Math.cos(angle) * planetData.radius * 1.4;
                drip.position.z = Math.sin(angle) * planetData.radius * 1.4;
                drip.userData.drip = true;
                drip.userData.angle = angle;
                drip.userData.offset = Math.random() * Math.PI * 2;
                planet.add(drip);
            }
            
            planetGroup.add(planet);
            scene.add(planetGroup);
            celestialObjects.push(planetGroup);
            objectCount++;
            
            // Create moons with portal effect
            planetData.moons.forEach(moonData => {
                const moonGroup = new THREE.Group();
                
                const moonGeometry = new THREE.SphereGeometry(moonData.radius, 16, 16);
                const moonMaterial = new THREE.MeshToonMaterial({
                    color: moonData.color,
                    emissive: moonData.color,
                    emissiveIntensity: 0.2
                });
                const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.userData = moonData;
                moon.userData.type = 'moon';
                moon.userData.orbitDistance = moonData.distance;
                moon.userData.orbitSpeed = 0.02;
                moon.userData.orbitAngle = Math.random() * Math.PI * 2;
                moon.userData.parent = planet;
                
                const moonOutlineGeometry = new THREE.SphereGeometry(moonData.radius * 1.08, 16, 16);
                const moonOutlineMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    side: THREE.BackSide
                });
                const moonOutline = new THREE.Mesh(moonOutlineGeometry, moonOutlineMaterial);
                moon.add(moonOutline);
                
                // Small portal ring for moons
                const moonRingGeometry = new THREE.TorusGeometry(moonData.radius * 1.2, moonData.radius * 0.06, 12, 24);
                const moonRingMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.4
                });
                const moonRing = new THREE.Mesh(moonRingGeometry, moonRingMaterial);
                moonRing.rotation.x = Math.PI / 2;
                moonRing.userData.portalRing = true;
                moon.add(moonRing);
                
                moonGroup.add(moon);
                planetGroup.add(moonGroup);
                celestialObjects.push(moonGroup);
                objectCount++;
            });
        });
        
        // Create dwarf planets - Rick and Morty style
        solarSystemData.dwarfPlanets.forEach(dwarfData => {
            const dwarfGroup = new THREE.Group();
            
            const orbitGeometry = new THREE.BufferGeometry();
            const orbitPoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                orbitPoints.push(
                    Math.cos(angle) * dwarfData.distance,
                    0,
                    Math.sin(angle) * dwarfData.distance
                );
            }
            orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
            const orbitMaterial = new THREE.LineBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.4
            });
            const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
            orbitLine.userData.orbit = true;
            scene.add(orbitLine);
            orbitLines.push(orbitLine);
            
            const dwarfGeometry = new THREE.SphereGeometry(dwarfData.radius, 20, 20);
            const dwarfMaterial = new THREE.MeshToonMaterial({
                color: dwarfData.color,
                emissive: dwarfData.color,
                emissiveIntensity: 0.3
            });
            const dwarf = new THREE.Mesh(dwarfGeometry, dwarfMaterial);
            dwarf.userData = dwarfData;
            dwarf.userData.orbitDistance = dwarfData.distance;
            dwarf.userData.orbitSpeed = dwarfData.orbitSpeed;
            dwarf.userData.orbitAngle = Math.random() * Math.PI * 2;
            
            const outlineGeometry = new THREE.SphereGeometry(dwarfData.radius * 1.08, 20, 20);
            const outlineMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                side: THREE.BackSide
            });
            const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
            dwarf.add(outline);
            
            // Orange portal ring for Pluto
            const ringGeometry = new THREE.TorusGeometry(dwarfData.radius * 1.3, dwarfData.radius * 0.08, 16, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.5
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.userData.portalRing = true;
            dwarf.add(ring);
            
            dwarfGroup.add(dwarf);
            scene.add(dwarfGroup);
            celestialObjects.push(dwarfGroup);
            objectCount++;
            
            // Create Pluto's moons
            dwarfData.moons.forEach(moonData => {
                const moonGroup = new THREE.Group();
                
                const moonGeometry = new THREE.SphereGeometry(moonData.radius, 16, 16);
                const moonMaterial = new THREE.MeshToonMaterial({
                    color: moonData.color,
                    emissive: moonData.color,
                    emissiveIntensity: 0.2
                });
                const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.userData = moonData;
                moon.userData.type = 'moon';
                moon.userData.orbitDistance = moonData.distance;
                moon.userData.orbitSpeed = 0.03;
                moon.userData.orbitAngle = Math.random() * Math.PI * 2;
                moon.userData.parent = dwarf;
                
                const moonOutlineGeometry = new THREE.SphereGeometry(moonData.radius * 1.08, 16, 16);
                const moonOutlineMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    side: THREE.BackSide
                });
                const moonOutline = new THREE.Mesh(moonOutlineGeometry, moonOutlineMaterial);
                moon.add(moonOutline);
                
                moonGroup.add(moon);
                dwarfGroup.add(moonGroup);
                celestialObjects.push(moonGroup);
                objectCount++;
            });
        });
        
        document.getElementById('obj-count').textContent = objectCount;
        
        // Interaction variables
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        const celestialInfo = document.getElementById('celestial-info');
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let selectedObject = null;
        
        // Touch controls
        let touchStartDistance = 0;
        let initialCameraZ = camera.position.z;
        let isTouching = false;
        
        // Mouse events
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        renderer.domElement.addEventListener('mousemove', handleMove);
        
        // Touch events
        renderer.domElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isTouching = true;
            
            if (e.touches.length === 1) {
                previousMousePosition = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                initialCameraZ = camera.position.z;
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.005;
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * rotationSpeed);
                
                const right = new THREE.Vector3();
                camera.getWorldDirection(right);
                right.cross(camera.up).normalize();
                
                previousMousePosition = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
                
                camera.lookAt(0, 0, 0);
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const scale = touchStartDistance / distance;
                const newZ = initialCameraZ * scale;
                
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                dir.normalize();
                
                const currentDistance = camera.position.length();
                const targetDistance = Math.max(15, Math.min(150, newZ));
                
                camera.position.normalize().multiplyScalar(targetDistance);
                camera.lookAt(0, 0, 0);
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                isTouching = false;
                
                if (e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    const allMeshes = [];
                    celestialObjects.forEach(group => {
                        group.traverse(obj => {
                            if (obj.isMesh && obj.userData.name) {
                                allMeshes.push(obj);
                            }
                        });
                    });
                    
                    const intersects = raycaster.intersectObjects(allMeshes);
                    
                    if (intersects.length > 0) {
                        selectObject(intersects[0].object);
                    }
                }
            }
        });
        
        function handleMove(e) {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.005;
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * rotationSpeed);
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
                camera.lookAt(0, 0, 0);
            }
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            if (!isTouching) {
                raycaster.setFromCamera(mouse, camera);
                
                const allMeshes = [];
                celestialObjects.forEach(group => {
                    group.traverse(obj => {
                        if (obj.isMesh && obj.userData.name) {
                            allMeshes.push(obj);
                        }
                    });
                });
                
                const intersects = raycaster.intersectObjects(allMeshes);
                
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    const data = obj.userData;
                    
                    tooltip.style.display = 'block';
                    tooltip.style.left = e.clientX + 15 + 'px';
                    tooltip.style.top = e.clientY + 15 + 'px';
                    
                    const typeClass = `type-${data.type}`;
                    tooltip.innerHTML = `
                        <strong style="color: #00ffff;">${data.name}</strong>
                        <span class="type-tag ${typeClass}">${data.type.toUpperCase()}</span><br>
                        <em>${data.info}</em>
                    `;
                } else {
                    tooltip.style.display = 'none';
                }
            }
        }
        
        renderer.domElement.addEventListener('click', (e) => {
            if (isTouching) return;
            
            raycaster.setFromCamera(mouse, camera);
            
            const allMeshes = [];
            celestialObjects.forEach(group => {
                group.traverse(obj => {
                    if (obj.isMesh && obj.userData.name) {
                        allMeshes.push(obj);
                    }
                });
            });
            
            const intersects = raycaster.intersectObjects(allMeshes);
            
            if (intersects.length > 0) {
                selectObject(intersects[0].object);
            }
        });
        
        function selectObject(obj) {
            if (selectedObject) {
                selectedObject.material.emissiveIntensity = 0.2;
            }
            
            selectedObject = obj;
            selectedObject.material.emissiveIntensity = 0.8;
            
            const data = selectedObject.userData;
            const typeClass = `type-${data.type}`;
            
            let factsHTML = '';
            if (data.facts) {
                factsHTML = '<div><strong>Facts:</strong></div><div style="margin-left: 10px;">';
                factsHTML += data.facts.map(f => `â€¢ ${f}`).join('<br>');
                factsHTML += '</div>';
            }
            
            // Rick's snarky comments
            const rickComments = {
                'Sun': "*burp* It's a giant ball of nuclear fusion, Morty. Don't stare at it.",
                'Mercury': "Closest to the sun. Hotter than your mix tape, Morty.",
                'Venus': "Toxic atmosphere, acid rain, 900 degrees. Basically your aunt's house.",
                'Earth': "C-137's version got Cronenberged. This one's... okay I guess.",
                'Moon': "Allegedly made of cheese. Allegedly. *burp*",
                'Mars': "Red planet. Elon's wet dream. Probably gonna terraform it wrong.",
                'Jupiter': "*burp* Big boy. Could fit like a thousand Earths. Who's counting though?",
                'Saturn': "Ooh look at me, I have rings! *burp* Show off.",
                'Uranus': "Hehe. You said Uranus. Classic Morty.",
                'Neptune': "It's blue, it's far, it's got supersonic winds. What else you want?",
                'Pluto': "NOT A PLANET ANYMORE, MORTY! Get over it!",
                'Titan': "Saturn's moon with atmosphere. Could have life. Probably doesn't.",
                'Europa': "Ice moon with ocean. Might have alien fish. Might not. *burp*",
                'Io': "Most volcanically active body. Like my stomach after Taco Bell.",
                'Ganymede': "Biggest moon in the solar system. Overachiever."
            };
            
            const rickComment = rickComments[data.name] || "*burp* Yeah, it's a celestial body, Morty. What'd you expect?";
            
            celestialInfo.innerHTML = `
                <div class="celestial-label">${data.name}</div>
                <span class="type-tag ${typeClass}">${data.type.toUpperCase()}</span><br>
                <div style="margin-top: 5px;"><strong>Info:</strong> ${data.info}</div>
                ${factsHTML}
                <div style="margin-top: 8px; padding: 5px; background: rgba(0, 100, 0, 0.3); border-left: 2px solid #00ffff; font-style: italic; color: #00ffff; font-size: 9px;">
                    ${rickComment}
                </div>
            `;
        }
        
        // Zoom with mouse wheel
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const zoomSpeed = 0.1;
            const currentDistance = camera.position.length();
            const newDistance = currentDistance + e.deltaY * zoomSpeed;
            const clampedDistance = Math.max(15, Math.min(150, newDistance));
            
            camera.position.normalize().multiplyScalar(clampedDistance);
            camera.lookAt(0, 0, 0);
        }, { passive: false });
        
        // View control functions
        function setView(viewType) {
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            let targetPos;
            switch(viewType) {
                case 'overview':
                    targetPos = new THREE.Vector3(0, 40, 80);
                    document.getElementById('current-view').textContent = 'Overview';
                    break;
                case 'inner':
                    targetPos = new THREE.Vector3(0, 15, 30);
                    document.getElementById('current-view').textContent = 'Inner System';
                    break;
                case 'outer':
                    targetPos = new THREE.Vector3(0, 30, 120);
                    document.getElementById('current-view').textContent = 'Outer System';
                    break;
            }
            
            animateCamera(targetPos);
        }
        
        function resetCamera() {
            animateCamera(new THREE.Vector3(0, 40, 80));
            document.getElementById('current-view').textContent = 'Overview';
            document.querySelectorAll('.view-btn').forEach((btn, i) => {
                btn.classList.remove('active');
                if (i === 0) btn.classList.add('active');
            });
        }
        
        function animateCamera(targetPos) {
            const startPos = camera.position.clone();
            const duration = 1000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPos, targetPos, eased);
                camera.lookAt(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        // Portal Jump Effect - Rick and Morty style
        function portalJump() {
            // Create portal flash
            const portalFlash = new THREE.PointLight(0x00ff00, 10, 50);
            portalFlash.position.copy(camera.position);
            scene.add(portalFlash);
            
            // Create expanding portal ring
            const portalRingGeometry = new THREE.TorusGeometry(2, 0.5, 16, 32);
            const portalRingMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 1,
                side: THREE.DoubleSide
            });
            const portalRing = new THREE.Mesh(portalRingGeometry, portalRingMaterial);
            portalRing.position.copy(camera.position);
            portalRing.lookAt(0, 0, 0);
            scene.add(portalRing);
            
            // Create portal liquid splatter particles
            const particles = [];
            for (let i = 0; i < 30; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(camera.position);
                
                const angle = (i / 30) * Math.PI * 2;
                const speed = 0.3 + Math.random() * 0.3;
                particle.userData.velocity = new THREE.Vector3(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    (Math.random() - 0.5) * speed
                );
                scene.add(particle);
                particles.push(particle);
            }
            
            // Random planet to jump to
            const randomPlanet = celestialObjects[Math.floor(Math.random() * celestialObjects.length)];
            let targetPosition;
            randomPlanet.traverse(obj => {
                if (obj.userData.name && obj.userData.orbitDistance) {
                    const distance = obj.userData.orbitDistance + 8;
                    targetPosition = new THREE.Vector3(
                        obj.position.x + distance,
                        distance * 0.5,
                        obj.position.z + distance
                    );
                }
            });
            
            if (!targetPosition) {
                targetPosition = new THREE.Vector3(
                    Math.random() * 40 - 20,
                    20,
                    Math.random() * 40 - 20
                );
            }
            
            // Animate portal effect
            let frame = 0;
            const portalAnimation = setInterval(() => {
                frame++;
                
                // Expand and fade ring
                const scale = 1 + frame * 0.4;
                portalRing.scale.set(scale, scale, scale);
                portalRing.material.opacity = Math.max(0, 1 - (frame / 25));
                portalRing.rotation.z += 0.1;
                
                // Move and fade particles with drip effect
                particles.forEach(p => {
                    p.position.add(p.userData.velocity);
                    p.userData.velocity.y -= 0.02; // Gravity drip
                    p.material.opacity = Math.max(0, 1 - (frame / 25));
                    
                    const wobble = Math.sin(frame * 0.3) * 0.1;
                    p.scale.set(1 + wobble, 1 + wobble, 1 + wobble);
                });
                
                // Dim and flicker light
                portalFlash.intensity = Math.max(0, 10 - frame * 0.5);
                
                if (frame >= 25) {
                    clearInterval(portalAnimation);
                    scene.remove(portalFlash);
                    scene.remove(portalRing);
                    particles.forEach(p => scene.remove(p));
                }
            }, 30);
            
            // Jump camera after short delay
            setTimeout(() => {
                animateCamera(targetPosition);
                
                // Show Rick's comment
                const comments = [
                    "*burp* There we go, Morty!",
                    "Wubba lubba dub dub!",
                    "And that's the wayyyy the news goes!",
                    "Grassssss tastes bad!",
                    "Lick lick lick my balls!",
                    "Hit the sack, Jack!",
                    "Uh oh, somersault jump!",
                    "AIDS!",
                    "No jumping in the sewer!"
                ];
                const randomComment = comments[Math.floor(Math.random() * comments.length)];
                
                celestialInfo.innerHTML = `
                    <div class="celestial-label">Portal Jump Complete!</div>
                    <div style="margin-top: 5px; color: #00ffff; font-style: italic;">
                        ${randomComment}
                    </div>
                `;
            }, 300);
        }
        
        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Animate sun with Rick and Morty effects
            sunGroup.rotation.y += 0.005;
            
            sunGroup.traverse(obj => {
                // Animate glow layers
                if (obj.userData.glowLayer) {
                    const layer = obj.userData.glowLayer;
                    obj.rotation.y += 0.01 * layer;
                    const pulse = Math.sin(time * 2 + layer) * 0.1 + 1;
                    obj.scale.set(pulse, pulse, pulse);
                }
                
                // Animate sun particles
                if (obj.userData.sunParticle) {
                    obj.userData.angle += obj.userData.speed;
                    const wobble = Math.sin(time * 3 + obj.userData.angle) * 0.3;
                    obj.position.x = Math.cos(obj.userData.angle) * (obj.userData.radius + wobble);
                    obj.position.y = Math.sin(obj.userData.angle) * (obj.userData.radius + wobble);
                    obj.position.z = Math.sin(time * 2 + obj.userData.angle) * 0.5;
                    
                    const scale = 0.7 + Math.sin(time * 4 + obj.userData.angle) * 0.3;
                    obj.scale.set(scale, scale, scale);
                }
            });
            
            // Orbit planets with portal effects
            celestialObjects.forEach(group => {
                group.traverse(obj => {
                    // Animate portal rings
                    if (obj.userData.portalRing) {
                        obj.rotation.z += 0.03;
                        const ringPulse = Math.sin(time * 3) * 0.1 + 0.9;
                        obj.scale.set(ringPulse, ringPulse, 1);
                        obj.material.opacity = 0.4 + Math.sin(time * 2) * 0.2;
                    }
                    
                    // Animate drips
                    if (obj.userData.drip) {
                        const angle = obj.userData.angle;
                        const offset = obj.userData.offset;
                        const dripWobble = Math.sin(time * 3 + offset) * 0.3;
                        obj.position.y = Math.sin(time * 2 + offset) * 0.4 - 0.2;
                        
                        const dripScale = 0.6 + Math.sin(time * 4 + offset) * 0.4;
                        obj.scale.set(dripScale, dripScale, dripScale);
                        obj.material.opacity = 0.5 + Math.sin(time * 3 + offset) * 0.3;
                    }
                    
                    if (obj.userData.orbitSpeed !== undefined && obj.userData.orbitDistance !== undefined) {
                        obj.userData.orbitAngle += obj.userData.orbitSpeed;
                        
                        if (obj.userData.type === 'moon' && obj.userData.parent) {
                            // Moon orbits around its parent planet
                            obj.position.x = Math.cos(obj.userData.orbitAngle) * obj.userData.orbitDistance;
                            obj.position.z = Math.sin(obj.userData.orbitAngle) * obj.userData.orbitDistance;
                            obj.position.y = Math.sin(obj.userData.orbitAngle * 2) * 0.2; // Slight vertical wobble
                        } else {
                            // Planet orbits around sun
                            obj.position.x = Math.cos(obj.userData.orbitAngle) * obj.userData.orbitDistance;
                            obj.position.z = Math.sin(obj.userData.orbitAngle) * obj.userData.orbitDistance;
                        }
                        
                        obj.rotation.y += 0.01;
                    }
                });
            });
            
            // Animate orbit lines with portal energy
            orbitLines.forEach((line, i) => {
                if (line.userData.orbit) {
                    line.material.opacity = 0.3 + Math.sin(time * 2 + i) * 0.2;
                }
            });
            
            // Rotate starfield with Rick and Morty space effect
            stars.rotation.y += 0.0002;
            stars.rotation.x += 0.0001;
            
            // Make stars twinkle
            const positions = stars.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                if (Math.random() > 0.995) {
                    positions[i + 1] += (Math.random() - 0.5) * 0.1;
                }
            }
            stars.geometry.attributes.position.needsUpdate = true;
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
