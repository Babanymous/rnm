<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System - Rick's Database</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
            color: #00ff00;
            touch-action: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 12px;
            font-size: 11px;
            max-width: 320px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        #hud h2 {
            color: #00ffff;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #00ffff;
            font-size: 14px;
        }
        
        #celestial-info {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 50, 0, 0.5);
            border-left: 3px solid #00ff00;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .celestial-label {
            color: #ffff00;
            font-weight: bold;
        }
        
        .status {
            color: #00ff00;
            animation: blink 1.5s infinite;
        }
        
        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.5; }
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 10px;
            font-size: 10px;
            z-index: 100;
        }
        
        #view-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 10px;
            z-index: 100;
        }
        
        .view-btn {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 8px 12px;
            margin: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            transition: all 0.2s;
        }
        
        .view-btn:active, .view-btn.active {
            background: rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ffff;
            padding: 8px;
            font-size: 10px;
            pointer-events: none;
            display: none;
            z-index: 200;
            max-width: 250px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }
        
        .type-tag {
            display: inline-block;
            padding: 2px 6px;
            margin-left: 5px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: bold;
        }
        
        .type-star { background: #ffff00; color: #000; }
        .type-planet { background: #0088ff; color: #fff; }
        .type-moon { background: #aaaaaa; color: #000; }
        .type-dwarf { background: #ff6600; color: #fff; }
        
        @media (max-width: 768px) {
            #hud {
                font-size: 9px;
                max-width: 220px;
                padding: 8px;
            }
            
            #hud h2 {
                font-size: 11px;
            }
            
            #controls {
                font-size: 8px;
                padding: 6px;
            }
            
            .view-btn {
                padding: 6px 10px;
                font-size: 9px;
                margin: 2px;
            }
            
            #view-controls {
                padding: 6px;
            }
        }
        
        @media (max-width: 480px) {
            #hud {
                font-size: 8px;
                max-width: 160px;
                padding: 6px;
            }
            
            #hud h2 {
                font-size: 10px;
            }
            
            #controls {
                font-size: 7px;
                padding: 5px;
                max-width: 140px;
            }
            
            .view-btn {
                padding: 5px 8px;
                font-size: 8px;
            }
            
            .tooltip {
                font-size: 8px;
                max-width: 180px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="hud">
        <h2>SOLAR SYSTEM DATABASE</h2>
        <div>Status: <span class="status">SCANNING</span></div>
        <div>Objects Tracked: <span id="obj-count">0</span></div>
        <div>Current View: <span id="current-view">Overview</span></div>
        <div id="celestial-info">
            <div class="celestial-label">Tap/Click any object for details</div>
        </div>
    </div>
    
    <div id="view-controls">
        <button class="view-btn active" onclick="setView('overview')">OVERVIEW</button><br>
        <button class="view-btn" onclick="setView('inner')">INNER SYSTEM</button><br>
        <button class="view-btn" onclick="setView('outer')">OUTER SYSTEM</button><br>
        <button class="view-btn" onclick="resetCamera()">RESET VIEW</button>
    </div>
    
    <div id="controls">
        <strong>CONTROLS:</strong><br>
        <strong>Desktop:</strong><br>
        • Drag: Rotate<br>
        • Wheel: Zoom<br>
        • Click: Info<br>
        <strong>Touch:</strong><br>
        • 1 Finger: Rotate<br>
        • Pinch: Zoom<br>
        • Tap: Select
    </div>
    
    <div id="tooltip" class="tooltip"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Solar System data with major moons
        const solarSystemData = {
            sun: {
                name: "Sun",
                type: "star",
                radius: 3.0,
                color: 0xffff00,
                position: [0, 0, 0],
                info: "G-type main-sequence star. Powers the entire solar system.",
                facts: ["Mass: 1.989 × 10^30 kg", "Temperature: 5,778 K", "Age: 4.6 billion years"]
            },
            planets: [
                {
                    name: "Mercury",
                    type: "planet",
                    radius: 0.38,
                    color: 0x8c7853,
                    distance: 8,
                    orbitSpeed: 0.024,
                    info: "Smallest planet. Closest to the Sun.",
                    facts: ["No moons", "No atmosphere", "Day length: 59 Earth days"],
                    moons: []
                },
                {
                    name: "Venus",
                    type: "planet",
                    radius: 0.95,
                    color: 0xffc649,
                    distance: 12,
                    orbitSpeed: 0.015,
                    info: "Hottest planet. Thick toxic atmosphere.",
                    facts: ["No moons", "Toxic atmosphere", "Rotates backwards"],
                    moons: []
                },
                {
                    name: "Earth",
                    type: "planet",
                    radius: 1.0,
                    color: 0x0077be,
                    distance: 16,
                    orbitSpeed: 0.01,
                    info: "Our home planet. Only known planet with life.",
                    facts: ["1 moon", "71% water coverage", "Supports life"],
                    moons: [
                        { name: "Moon", radius: 0.27, distance: 1.5, color: 0xaaaaaa, info: "Earth's only natural satellite" }
                    ]
                },
                {
                    name: "Mars",
                    type: "planet",
                    radius: 0.53,
                    color: 0xcd5c5c,
                    distance: 20,
                    orbitSpeed: 0.008,
                    info: "The Red Planet. Target for human colonization.",
                    facts: ["2 moons", "Largest volcano in solar system", "Polar ice caps"],
                    moons: [
                        { name: "Phobos", radius: 0.12, distance: 0.8, color: 0x999999, info: "Larger moon of Mars" },
                        { name: "Deimos", radius: 0.08, distance: 1.2, color: 0x888888, info: "Smaller moon of Mars" }
                    ]
                },
                {
                    name: "Jupiter",
                    type: "planet",
                    radius: 2.2,
                    color: 0xdaa520,
                    distance: 32,
                    orbitSpeed: 0.004,
                    info: "Largest planet. Gas giant with Great Red Spot.",
                    facts: ["95+ moons", "Strongest magnetic field", "Could fit 1,300 Earths"],
                    moons: [
                        { name: "Io", radius: 0.28, distance: 3.0, color: 0xffaa00, info: "Most volcanically active body" },
                        { name: "Europa", radius: 0.24, distance: 3.8, color: 0xccddff, info: "Subsurface ocean, potential life" },
                        { name: "Ganymede", radius: 0.41, distance: 4.6, color: 0xaaaaaa, info: "Largest moon in solar system" },
                        { name: "Callisto", radius: 0.37, distance: 5.4, color: 0x8b7355, info: "Heavily cratered surface" }
                    ]
                },
                {
                    name: "Saturn",
                    type: "planet",
                    radius: 1.8,
                    color: 0xfad5a5,
                    distance: 48,
                    orbitSpeed: 0.003,
                    info: "Gas giant with spectacular ring system.",
                    facts: ["146+ moons", "Iconic rings", "Least dense planet"],
                    moons: [
                        { name: "Titan", radius: 0.40, distance: 4.5, color: 0xff9944, info: "Only moon with dense atmosphere" },
                        { name: "Rhea", radius: 0.12, distance: 3.2, color: 0xcccccc, info: "Second largest moon of Saturn" },
                        { name: "Iapetus", radius: 0.11, distance: 5.8, color: 0x888888, info: "Two-toned coloration" },
                        { name: "Dione", radius: 0.09, distance: 2.8, color: 0xbbbbbb, info: "Icy surface with cliffs" },
                        { name: "Tethys", radius: 0.08, distance: 2.2, color: 0xdddddd, info: "Heavily cratered" },
                        { name: "Enceladus", radius: 0.04, distance: 1.8, color: 0xffffff, info: "Water geysers, potential life" },
                        { name: "Mimas", radius: 0.03, distance: 1.4, color: 0xaaaaaa, info: "Death Star lookalike" }
                    ]
                },
                {
                    name: "Uranus",
                    type: "planet",
                    radius: 1.3,
                    color: 0x4fd0e0,
                    distance: 64,
                    orbitSpeed: 0.002,
                    info: "Ice giant. Rotates on its side.",
                    facts: ["27+ moons", "Rotates sideways", "Methane atmosphere"],
                    moons: [
                        { name: "Titania", radius: 0.12, distance: 2.8, color: 0xaaaaaa, info: "Largest moon of Uranus" },
                        { name: "Oberon", radius: 0.11, distance: 3.4, color: 0x999999, info: "Heavily cratered" },
                        { name: "Umbriel", radius: 0.09, distance: 2.0, color: 0x777777, info: "Darkest moon" },
                        { name: "Ariel", radius: 0.09, distance: 1.6, color: 0xbbbbbb, info: "Brightest surface" },
                        { name: "Miranda", radius: 0.04, distance: 1.2, color: 0xcccccc, info: "Bizarre patchwork surface" }
                    ]
                },
                {
                    name: "Neptune",
                    type: "planet",
                    radius: 1.2,
                    color: 0x4169e1,
                    distance: 80,
                    orbitSpeed: 0.001,
                    info: "Farthest major planet. Fastest winds in solar system.",
                    facts: ["14+ moons", "Great Dark Spot", "Supersonic winds"],
                    moons: [
                        { name: "Triton", radius: 0.21, distance: 2.8, color: 0xffbbdd, info: "Largest moon, retrograde orbit" },
                        { name: "Proteus", radius: 0.08, distance: 3.5, color: 0x888888, info: "Irregular shape" },
                        { name: "Nereid", radius: 0.03, distance: 5.0, color: 0xaaaaaa, info: "Highly eccentric orbit" }
                    ]
                }
            ],
            dwarfPlanets: [
                {
                    name: "Pluto",
                    type: "dwarf",
                    radius: 0.18,
                    color: 0xc4a582,
                    distance: 96,
                    orbitSpeed: 0.0008,
                    info: "Former 9th planet. Dwarf planet in Kuiper Belt.",
                    facts: ["5 moons", "Heart-shaped region", "Still a planet to some"],
                    moons: [
                        { name: "Charon", radius: 0.095, distance: 0.9, color: 0xaaaaaa, info: "Half the size of Pluto" }
                    ]
                }
            ]
        };
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);
        scene.fog = new THREE.Fog(0x000510, 50, 200);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, 40, 80);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting
        const sunLight = new THREE.PointLight(0xffff00, 2, 300);
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);
        
        const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
        scene.add(ambientLight);
        
        // Create starfield
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        const starColors = [];
        for (let i = 0; i < 5000; i++) {
            const x = (Math.random() - 0.5) * 400;
            const y = (Math.random() - 0.5) * 400;
            const z = (Math.random() - 0.5) * 400;
            starVertices.push(x, y, z);
            
            const colorChoice = Math.random();
            if (colorChoice < 0.7) {
                starColors.push(1, 1, 1);
            } else if (colorChoice < 0.85) {
                starColors.push(0.5, 0.8, 1);
            } else {
                starColors.push(0.3, 1, 0.7);
            }
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        const starMaterial = new THREE.PointsMaterial({ 
            size: 0.2,
            vertexColors: true,
            transparent: true,
            opacity: 0.9
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        
        // Create celestial objects
        const celestialObjects = [];
        const orbitLines = [];
        let objectCount = 0;
        
        // Create Sun
        const sunGroup = new THREE.Group();
        const sunGeometry = new THREE.SphereGeometry(solarSystemData.sun.radius, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: solarSystemData.sun.color,
            emissive: solarSystemData.sun.color,
            emissiveIntensity: 1
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.userData = solarSystemData.sun;
        
        // Sun glow
        const sunGlowGeometry = new THREE.SphereGeometry(solarSystemData.sun.radius * 1.5, 32, 32);
        const sunGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xffff00,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
        sun.add(sunGlow);
        
        sunGroup.add(sun);
        scene.add(sunGroup);
        celestialObjects.push(sunGroup);
        objectCount++;
        
        // Create planets with moons
        solarSystemData.planets.forEach(planetData => {
            const planetGroup = new THREE.Group();
            
            // Create orbit line
            const orbitGeometry = new THREE.BufferGeometry();
            const orbitPoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                orbitPoints.push(
                    Math.cos(angle) * planetData.distance,
                    0,
                    Math.sin(angle) * planetData.distance
                );
            }
            orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
            const orbitMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.2
            });
            const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
            scene.add(orbitLine);
            orbitLines.push(orbitLine);
            
            // Create planet
            const planetGeometry = new THREE.SphereGeometry(planetData.radius, 24, 24);
            const planetMaterial = new THREE.MeshToonMaterial({
                color: planetData.color,
                emissive: planetData.color,
                emissiveIntensity: 0.2
            });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            planet.userData = planetData;
            planet.userData.orbitDistance = planetData.distance;
            planet.userData.orbitSpeed = planetData.orbitSpeed;
            planet.userData.orbitAngle = Math.random() * Math.PI * 2;
            
            // Planet outline
            const outlineGeometry = new THREE.SphereGeometry(planetData.radius * 1.05, 24, 24);
            const outlineMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                side: THREE.BackSide
            });
            const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
            planet.add(outline);
            
            planetGroup.add(planet);
            scene.add(planetGroup);
            celestialObjects.push(planetGroup);
            objectCount++;
            
            // Create moons
            planetData.moons.forEach(moonData => {
                const moonGroup = new THREE.Group();
                
                const moonGeometry = new THREE.SphereGeometry(moonData.radius, 16, 16);
                const moonMaterial = new THREE.MeshToonMaterial({
                    color: moonData.color,
                    emissive: moonData.color,
                    emissiveIntensity: 0.1
                });
                const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.userData = moonData;
                moon.userData.type = 'moon';
                moon.userData.orbitDistance = moonData.distance;
                moon.userData.orbitSpeed = 0.02;
                moon.userData.orbitAngle = Math.random() * Math.PI * 2;
                moon.userData.parent = planet;
                
                const moonOutlineGeometry = new THREE.SphereGeometry(moonData.radius * 1.05, 16, 16);
                const moonOutlineMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    side: THREE.BackSide
                });
                const moonOutline = new THREE.Mesh(moonOutlineGeometry, moonOutlineMaterial);
                moon.add(moonOutline);
                
                moonGroup.add(moon);
                planetGroup.add(moonGroup);
                celestialObjects.push(moonGroup);
                objectCount++;
            });
        });
        
        // Create dwarf planets
        solarSystemData.dwarfPlanets.forEach(dwarfData => {
            const dwarfGroup = new THREE.Group();
            
            const orbitGeometry = new THREE.BufferGeometry();
            const orbitPoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                orbitPoints.push(
                    Math.cos(angle) * dwarfData.distance,
                    0,
                    Math.sin(angle) * dwarfData.distance
                );
            }
            orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
            const orbitMaterial = new THREE.LineBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.3
            });
            const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
            scene.add(orbitLine);
            orbitLines.push(orbitLine);
            
            const dwarfGeometry = new THREE.SphereGeometry(dwarfData.radius, 20, 20);
            const dwarfMaterial = new THREE.MeshToonMaterial({
                color: dwarfData.color,
                emissive: dwarfData.color,
                emissiveIntensity: 0.2
            });
            const dwarf = new THREE.Mesh(dwarfGeometry, dwarfMaterial);
            dwarf.userData = dwarfData;
            dwarf.userData.orbitDistance = dwarfData.distance;
            dwarf.userData.orbitSpeed = dwarfData.orbitSpeed;
            dwarf.userData.orbitAngle = Math.random() * Math.PI * 2;
            
            const outlineGeometry = new THREE.SphereGeometry(dwarfData.radius * 1.05, 20, 20);
            const outlineMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                side: THREE.BackSide
            });
            const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
            dwarf.add(outline);
            
            dwarfGroup.add(dwarf);
            scene.add(dwarfGroup);
            celestialObjects.push(dwarfGroup);
            objectCount++;
            
            // Create Pluto's moons
            dwarfData.moons.forEach(moonData => {
                const moonGroup = new THREE.Group();
                
                const moonGeometry = new THREE.SphereGeometry(moonData.radius, 16, 16);
                const moonMaterial = new THREE.MeshToonMaterial({
                    color: moonData.color,
                    emissive: moonData.color,
                    emissiveIntensity: 0.1
                });
                const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.userData = moonData;
                moon.userData.type = 'moon';
                moon.userData.orbitDistance = moonData.distance;
                moon.userData.orbitSpeed = 0.03;
                moon.userData.orbitAngle = Math.random() * Math.PI * 2;
                moon.userData.parent = dwarf;
                
                moonGroup.add(moon);
                dwarfGroup.add(moonGroup);
                celestialObjects.push(moonGroup);
                objectCount++;
            });
        });
        
        document.getElementById('obj-count').textContent = objectCount;
        
        // Interaction variables
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        const celestialInfo = document.getElementById('celestial-info');
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let selectedObject = null;
        
        // Touch controls
        let touchStartDistance = 0;
        let initialCameraZ = camera.position.z;
        let isTouching = false;
        
        // Mouse events
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        renderer.domElement.addEventListener('mousemove', handleMove);
        
        // Touch events
        renderer.domElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isTouching = true;
            
            if (e.touches.length === 1) {
                previousMousePosition = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                initialCameraZ = camera.position.z;
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.005;
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * rotationSpeed);
                
                const right = new THREE.Vector3();
                camera.getWorldDirection(right);
                right.cross(camera.up).normalize();
                
                previousMousePosition = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
                
                camera.lookAt(0, 0, 0);
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const scale = touchStartDistance / distance;
                const newZ = initialCameraZ * scale;
                
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                dir.normalize();
                
                const currentDistance = camera.position.length();
                const targetDistance = Math.max(15, Math.min(150, newZ));
                
                camera.position.normalize().multiplyScalar(targetDistance);
                camera.lookAt(0, 0, 0);
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                isTouching = false;
                
                if (e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    const allMeshes = [];
                    celestialObjects.forEach(group => {
                        group.traverse(obj => {
                            if (obj.isMesh && obj.userData.name) {
                                allMeshes.push(obj);
                            }
                        });
                    });
                    
                    const intersects = raycaster.intersectObjects(allMeshes);
                    
                    if (intersects.length > 0) {
                        selectObject(intersects[0].object);
                    }
                }
            }
        });
        
        function handleMove(e) {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.005;
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * rotationSpeed);
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
                camera.lookAt(0, 0, 0);
            }
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            if (!isTouching) {
                raycaster.setFromCamera(mouse, camera);
                
                const allMeshes = [];
                celestialObjects.forEach(group => {
                    group.traverse(obj => {
                        if (obj.isMesh && obj.userData.name) {
                            allMeshes.push(obj);
                        }
                    });
                });
                
                const intersects = raycaster.intersectObjects(allMeshes);
                
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    const data = obj.userData;
                    
                    tooltip.style.display = 'block';
                    tooltip.style.left = e.clientX + 15 + 'px';
                    tooltip.style.top = e.clientY + 15 + 'px';
                    
                    const typeClass = `type-${data.type}`;
                    tooltip.innerHTML = `
                        <strong style="color: #00ffff;">${data.name}</strong>
                        <span class="type-tag ${typeClass}">${data.type.toUpperCase()}</span><br>
                        <em>${data.info}</em>
                    `;
                } else {
                    tooltip.style.display = 'none';
                }
            }
        }
        
        renderer.domElement.addEventListener('click', (e) => {
            if (isTouching) return;
            
            raycaster.setFromCamera(mouse, camera);
            
            const allMeshes = [];
            celestialObjects.forEach(group => {
                group.traverse(obj => {
                    if (obj.isMesh && obj.userData.name) {
                        allMeshes.push(obj);
                    }
                });
            });
            
            const intersects = raycaster.intersectObjects(allMeshes);
            
            if (intersects.length > 0) {
                selectObject(intersects[0].object);
            }
        });
        
        function selectObject(obj) {
            if (selectedObject) {
                selectedObject.material.emissiveIntensity = 0.2;
            }
            
            selectedObject = obj;
            selectedObject.material.emissiveIntensity = 0.8;
            
            const data = selectedObject.userData;
            const typeClass = `type-${data.type}`;
            
            let factsHTML = '';
            if (data.facts) {
                factsHTML = '<div><strong>Facts:</strong></div><div style="margin-left: 10px;">';
                factsHTML += data.facts.map(f => `• ${f}`).join('<br>');
                factsHTML += '</div>';
            }
            
            celestialInfo.innerHTML = `
                <div class="celestial-label">${data.name}</div>
                <span class="type-tag ${typeClass}">${data.type.toUpperCase()}</span><br>
                <div style="margin-top: 5px;"><strong>Info:</strong> ${data.info}</div>
                ${factsHTML}
            `;
        }
        
        // Zoom with mouse wheel
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const zoomSpeed = 0.1;
            const currentDistance = camera.position.length();
            const newDistance = currentDistance + e.deltaY * zoomSpeed;
            const clampedDistance = Math.max(15, Math.min(150, newDistance));
            
            camera.position.normalize().multiplyScalar(clampedDistance);
            camera.lookAt(0, 0, 0);
        }, { passive: false });
        
        // View control functions
        function setView(viewType) {
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            let targetPos;
            switch(viewType) {
                case 'overview':
                    targetPos = new THREE.Vector3(0, 40, 80);
                    document.getElementById('current-view').textContent = 'Overview';
                    break;
                case 'inner':
                    targetPos = new THREE.Vector3(0, 15, 30);
                    document.getElementById('current-view').textContent = 'Inner System';
                    break;
                case 'outer':
                    targetPos = new THREE.Vector3(0, 30, 120);
                    document.getElementById('current-view').textContent = 'Outer System';
                    break;
            }
            
            animateCamera(targetPos);
        }
        
        function resetCamera() {
            animateCamera(new THREE.Vector3(0, 40, 80));
            document.getElementById('current-view').textContent = 'Overview';
            document.querySelectorAll('.view-btn').forEach((btn, i) => {
                btn.classList.remove('active');
                if (i === 0) btn.classList.add('active');
            });
        }
        
        function animateCamera(targetPos) {
            const startPos = camera.position.clone();
            const duration = 1000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPos, targetPos, eased);
                camera.lookAt(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Rotate sun
            sunGroup.rotation.y += 0.005;
            
            // Orbit planets
            celestialObjects.forEach(group => {
                group.traverse(obj => {
                    if (obj.userData.orbitSpeed !== undefined && obj.userData.orbitDistance !== undefined) {
                        obj.userData.orbitAngle += obj.userData.orbitSpeed;
                        
                        if (obj.userData.type === 'moon' && obj.userData.parent) {
                            // Moon orbits around its parent planet
                            const parentPos = obj.userData.parent.position;
                            obj.position.x = Math.cos(obj.userData.orbitAngle) * obj.userData.orbitDistance;
                            obj.position.z = Math.sin(obj.userData.orbitAngle) * obj.userData.orbitDistance;
                        } else {
                            // Planet orbits around sun
                            obj.position.x = Math.cos(obj.userData.orbitAngle) * obj.userData.orbitDistance;
                            obj.position.z = Math.sin(obj.userData.orbitAngle) * obj.userData.orbitDistance;
                        }
                        
                        obj.rotation.y += 0.01;
                    }
                });
            });
            
            // Pulse sun glow
            if (sunGlow) {
                sunGlow.scale.set(
                    1 + Math.sin(time * 2) * 0.1,
                    1 + Math.sin(time * 2) * 0.1,
                    1 + Math.sin(time * 2) * 0.1
                );
            }
            
            // Slowly rotate starfield
            stars.rotation.y += 0.0001;
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
