<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Central Finite Curve</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono:wght@300;400&display=swap');

        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Roboto Mono', monospace; }
        
        #ui-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-header {
            padding: 20px;
            background: linear-gradient(180deg, rgba(0,20,0,0.8) 0%, transparent 100%);
            border-bottom: 1px solid rgba(151, 206, 76, 0.3);
            text-shadow: 0 0 10px rgba(151, 206, 76, 0.8);
        }

        h1 { margin: 0; color: #97ce4c; font-family: 'Orbitron', sans-serif; font-size: 28px; letter-spacing: 2px; }
        .subtitle { color: #4cb5ce; font-size: 12px; margin-top: 5px; opacity: 0.8; }

        #scanner-modal {
            position: absolute;
            top: 50%; right: 20px;
            transform: translateY(-50%);
            width: 320px;
            background: rgba(10, 15, 10, 0.95);
            border: 1px solid #97ce4c;
            border-right: 4px solid #97ce4c;
            padding: 0;
            color: #fff;
            display: none;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: -10px 0 30px rgba(0,0,0,0.8);
        }

        .modal-header {
            background: rgba(151, 206, 76, 0.1);
            padding: 15px;
            border-bottom: 1px solid #333;
        }

        .modal-header h2 { margin: 0; color: #fff; font-size: 18px; font-family: 'Orbitron', sans-serif; }
        .modal-type { color: #97ce4c; font-size: 11px; text-transform: uppercase; margin-top: 5px; display: block; }

        .modal-body { padding: 15px; }
        
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 13px; }
        .stat-label { color: #888; }
        .stat-val { color: #eee; font-weight: bold; text-align: right; }

        .residents-box {
            margin-top: 15px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
        .res-title { font-size: 11px; color: #4cb5ce; text-transform: uppercase; margin-bottom: 8px; }
        #res-list {
            max-height: 100px;
            overflow-y: auto;
            font-size: 12px;
            color: #aaa;
            padding-left: 0;
            list-style: none;
            margin: 0;
        }
        #res-list li { padding: 2px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }

        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex; justify-content: center; align-items: center;
            z-index: 999;
            transition: opacity 1s ease;
        }
        .portal-spin {
            width: 50px; height: 50px;
            border: 4px solid #97ce4c;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        .scan-line {
            width: 100%; height: 2px; background: #97ce4c;
            position: absolute; top: 0; left: 0;
            animation: scan 2s linear infinite;
            opacity: 0.5;
            pointer-events: none;
        }
        @keyframes scan { 0% { top: 0; opacity: 0; } 50% { opacity: 1; } 100% { top: 100%; opacity: 0; } }

    </style>
</head>
<body>

    <div id="loading-overlay"><div class="portal-spin"></div></div>

    <div id="ui-container">
        <div class="hud-header">
            <h1>Multiverse Map</h1>
            <div class="subtitle">System: Central Finite Curve // Dimension C-137</div>
        </div>
    </div>

    <div id="scanner-modal">
        <div class="scan-line"></div>
        <div class="modal-header">
            <h2 id="info-name">Earth (C-137)</h2>
            <span class="modal-type" id="info-type">Planet</span>
        </div>
        <div class="modal-body">
            <div class="stat-row"><span class="stat-label">Dimension</span><span class="stat-val" id="info-dim">C-137</span></div>
            <div class="stat-row"><span class="stat-label">Population</span><span class="stat-val" id="info-pop">Unknown</span></div>
            
            <div class="residents-box">
                <div class="res-title">Detected Lifeforms</div>
                <ul id="res-list">
                    <li>Scanning...</li>
                </ul>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.maxDistance = 200;

        const ambientLight = new THREE.AmbientLight(0x404040, 2); 
        scene.add(ambientLight);
        
        const sunLight = new THREE.PointLight(0xffffff, 2, 300);
        sunLight.position.set(0, 50, 0);
        scene.add(sunLight);

        const greenGlow = new THREE.PointLight(0x97ce4c, 3, 100);
        greenGlow.position.set(0, 0, 0);
        scene.add(greenGlow);

        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const count = 5000;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);

            for(let i = 0; i < count; i++) {
                positions[i*3] = (Math.random() - 0.5) * 600;
                positions[i*3+1] = (Math.random() - 0.5) * 600;
                positions[i*3+2] = (Math.random() - 0.5) * 600;
                
                const colorType = Math.random();
                if(colorType > 0.9) { 
                    colors[i*3] = 0.59; colors[i*3+1] = 0.8; colors[i*3+2] = 0.3; 
                } else {
                    colors[i*3] = 0.8; colors[i*3+1] = 0.8; colors[i*3+2] = 0.9; 
                }
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({ size: 0.4, vertexColors: true, transparent: true, opacity: 0.8 });
            return new THREE.Points(geometry, material);
        }
        scene.add(createStarfield());

        function createCitadel() {
            const citadelGroup = new THREE.Group();

            const matDark = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.8 });
            const matLight = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4, metalness: 0.5 });
            const matGlass = new THREE.MeshStandardMaterial({ color: 0x97ce4c, emissive: 0x2a4411, transparent: true, opacity: 0.9 });

            const shaftGeo = new THREE.CylinderGeometry(2, 4, 30, 8);
            const shaft = new THREE.Mesh(shaftGeo, matDark);
            citadelGroup.add(shaft);

            const domeGeo = new THREE.SphereGeometry(6, 32, 16, 0, Math.PI * 2, 0, Math.PI/2);
            const dome = new THREE.Mesh(domeGeo, matGlass);
            dome.position.y = 8;
            dome.rotation.x = Math.PI; 
            citadelGroup.add(dome);

            const ringGeo = new THREE.TorusGeometry(12, 1.5, 16, 50);
            const ring = new THREE.Mesh(ringGeo, matLight);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = -5;
            citadelGroup.add(ring);

            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const satelliteGeo = new THREE.CylinderGeometry(1, 1, 4);
                const satellite = new THREE.Mesh(satelliteGeo, matDark);
                satellite.position.set(Math.cos(angle) * 12, -5, Math.sin(angle) * 12);
                citadelGroup.add(satellite);
            }

            const userData = {
                name: "The Citadel of Ricks",
                type: "Space Station",
                dimension: "unknown",
                residents: [], 
                isCitadel: true
            };
            
            shaft.userData = userData;
            dome.userData = userData;
            ring.userData = userData;

            citadelGroup.position.set(0, 0, 0);
            return citadelGroup;
        }

        const citadel = createCitadel();
        scene.add(citadel);

        const interactables = [];
        interactables.push(...citadel.children);

        function getShapeForType(type, color) {
            let geometry, material;
            
            const standardMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8, metalness: 0.1 });

            if (type.includes("Station") || type.includes("Citadel")) {
                geometry = new THREE.OctahedronGeometry(1.5, 0);
                material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.2, metalness: 0.9 });
            } 
            else if (type.includes("Microverse") || type.includes("Battery")) {
                geometry = new THREE.IcosahedronGeometry(1.2, 1);
                material = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            }
            else if (type.includes("Cluster")) {
                geometry = new THREE.DodecahedronGeometry(1.5, 0);
                material = standardMat;
            }
            else {
                geometry = new THREE.SphereGeometry(1.2, 16, 16);
                material = standardMat;
            }
            
            return new THREE.Mesh(geometry, material);
        }

        async function fetchUniverse() {
            try {
                const page1 = fetch('https://rickandmortyapi.com/api/location?page=1').then(r => r.json());
                const page2 = fetch('https://rickandmortyapi.com/api/location?page=2').then(r => r.json());
                const page3 = fetch('https://rickandmortyapi.com/api/location?page=3').then(r => r.json());

                const results = await Promise.all([page1, page2, page3]);
                const locations = [...results[0].results, ...results[1].results, ...results[2].results];

                document.getElementById('loading-overlay').style.opacity = 0;
                setTimeout(() => document.getElementById('loading-overlay').style.display = 'none', 1000);

                let angle = 0;
                let radius = 15; 

                locations.forEach((loc, index) => {
                    if (loc.name.includes("Citadel")) return; 

                    let colorHex;
                    switch(loc.type) {
                        case 'Planet': colorHex = 0x3498db; break;
                        case 'Cluster': colorHex = 0x9b59b6; break;
                        case 'Space Station': colorHex = 0x95a5a6; break;
                        case 'Microverse': colorHex = 0xe74c3c; break;
                        case 'TV': colorHex = 0xf1c40f; break; 
                        default: colorHex = 0x2ecc71;
                    }

                    const obj = getShapeForType(loc.type, colorHex);

                    angle += 0.5; 
                    radius += 0.2; 
                    
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 5;
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 5;
                    const y = (Math.random() - 0.5) * (radius * 0.3);

                    obj.position.set(x, y, z);
                    
                    obj.userData = {
                        name: loc.name,
                        type: loc.type,
                        dimension: loc.dimension,
                        residents: loc.residents
                    };

                    scene.add(obj);
                    interactables.push(obj);
                });

            } catch (err) {
                console.error("API Error", err);
            }
        }

        fetchUniverse();

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedObject = null;

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables);

            if (intersects.length > 0) {
                const target = intersects[0].object;
                
                if(selectedObject && selectedObject !== target && !selectedObject.userData.isCitadel) {
                    selectedObject.material.emissive.setHex(0x000000);
                }
                
                selectedObject = target;
                if(!target.userData.isCitadel && target.material.emissive) {
                    target.material.emissive.setHex(0x333333);
                }
                
                updateUI(target.userData);
                controls.autoRotate = false;
            } else {
                controls.autoRotate = true;
                document.getElementById('scanner-modal').style.display = 'none';
            }
        });

        async function updateUI(data) {
            const modal = document.getElementById('scanner-modal');
            const list = document.getElementById('res-list');
            
            modal.style.display = 'block';
            document.getElementById('info-name').innerText = data.name;
            document.getElementById('info-type').innerText = data.type;
            document.getElementById('info-dim').innerText = data.dimension;
            document.getElementById('info-pop').innerText = data.residents.length > 0 ? data.residents.length + " Lifeforms" : "Uninhabited";

            list.innerHTML = '<li>Accessing biometric database...</li>';

            if (data.residents.length === 0) {
                list.innerHTML = '<li>No lifeforms detected.</li>';
                return;
            }

            const residentUrls = data.residents.slice(0, 5);
            try {
                const fetches = residentUrls.map(url => fetch(url).then(res => res.json()));
                const residents = await Promise.all(fetches);
                
                list.innerHTML = '';
                residents.forEach(char => {
                    const li = document.createElement('li');
                    li.innerText = `> ${char.name} (${char.species})`;
                    list.appendChild(li);
                });
                
                if (data.residents.length > 5) {
                    const more = document.createElement('li');
                    more.style.fontStyle = 'italic';
                    more.innerText = `...and ${data.residents.length - 5} others`;
                    list.appendChild(more);
                }

            } catch (e) {
                list.innerHTML = '<li>Database Encryption Error.</li>';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            citadel.rotation.y += 0.002;
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
